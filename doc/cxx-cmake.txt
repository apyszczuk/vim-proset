*cxx-cmake.txt*   CXX CMake Settings Dictionary                    *cxx-cmake*

   ██████╗██╗  ██╗██╗  ██╗       ██████╗███╗   ███╗ █████╗ ██╗  ██╗███████╗
  ██╔════╝╚██╗██╔╝╚██╗██╔╝      ██╔════╝████╗ ████║██╔══██╗██║ ██╔╝██╔════╝
  ██║      ╚███╔╝  ╚███╔╝ █████╗██║     ██╔████╔██║███████║█████╔╝ █████╗  
  ██║      ██╔██╗  ██╔██╗ ╚════╝██║     ██║╚██╔╝██║██╔══██║██╔═██╗ ██╔══╝  
  ╚██████╗██╔╝ ██╗██╔╝ ██╗      ╚██████╗██║ ╚═╝ ██║██║  ██║██║  ██╗███████╗
   ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝       ╚═════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝

Author:     Artur Pyszczuk <apyszczuk@gmail.com>
License:    Same terms as Vim itself (see |license|)
Website:    https://github.com/apyszczuk/vim-proset

==============================================================================
TABLE OF CONTENTS
==============================================================================

INTRODUCTION                                          |cxx-cmake:introduction|
ASSUMPTIONS                                            |cxx-cmake:assumptions|
DEPENDENCIES                                          |cxx-cmake:dependencies|
API                                                            |cxx-cmake:api|
CONFIGURATION                                        |cxx-cmake:configuration|
CREATE PROJECT                                      |cxx-cmake:create_project|
VARIABLES                                                |cxx-cmake:variables|
CMAKE                                                        |cxx-cmake:cmake|
TEMPORARY                                                |cxx-cmake:temporary|
SOURCE                                                      |cxx-cmake:source|
BUILD                                                        |cxx-cmake:build|
RUN                                                            |cxx-cmake:run|
ALTERNATE FILE                                      |cxx-cmake:alternate_file|
CREATE HEADER                                        |cxx-cmake:create_header|
CREATE SOURCE                                        |cxx-cmake:create_source|
CREATE HEADER AND SOURCE                      |cxx-cmake:create_header_source|
SYMBOLS                                                    |cxx-cmake:symbols|
CTAGS                                                        |cxx-cmake:ctags|
CSCOPE                                                      |cxx-cmake:cscope|
DERIVATIVES (CXX-CMAKE-AP)                             |cxx-cmake:derivatives|
CONTRIBUTE                                              |cxx-cmake:contribute|

==============================================================================
INTRODUCTION                                          *cxx-cmake:introduction*
==============================================================================

Settings Dictionary |cxx-cmake| is supposed to be used when you want to write
C or C++ library or application using CMake as your build system.  Even though
CXX normally means C++, you are free to use it with C as well. All you have to
do is to change some entries in CMakeLists.txt and probably set header and
source files extensions in |proset:configuration:file| most likely to h and c.

Hopefully, you have already read |proset| documentation and you are familiar
with idea of Settings Dictionaries and Settings Objects in Proset plugin, if
not, go there first.

In short, when you use cxx-cmake Settings Object you will be able to (using
command or mapping):

    - build project,
    - clean project,
    - clean and build project,
    - run project (if not a library),
    - navigate through the source code with ease thanks to cscope and ctags,
    - switch between header and source files very easily,
    - create header file with include guard macro defined,
    - create source file with #include header file,
    - create header and source files (at once).

Additionally, you are able to create dummy cxx-cmake project very easily using
|ProsetCreate| function or command.

==============================================================================
ASSUMPTIONS                                            *cxx-cmake:assumptions*
==============================================================================

Just before we start, take a look:

    - each command starts with a colon ':' which means that in normal mode you
      type : and then name of a command (CXXCMake*),
    - each command ends with <CR> (enter/return),
    - if there is no explicit information that a command takes some arguments,
      then it takes 0 arguments,
    - tags in this document are in the form of cxx-cmake:section and some
      sections can be read as cxx-cmake:module, which means it is a module
      with functionalities.

==============================================================================
DEPENDENCIES                                          *cxx-cmake:dependencies*
==============================================================================

To make cxx-cmake Settings Object work correctly, you need to satisfy
|proset:dependencies| and have following ones installed:

    - +terminal     - support for inside terminal in Vim (|:version|),
    - +cscope       - support for cscope in Vim (|:version|)
    - vim-asyncrun  - plugin for running shell commands in the background and
                      read output in the quickfix window in realtime,
    - ctags         - application for generating tags file that Vim can read,
                      parse and use, preferably Universal Ctags 6.1.0 or
                      newer,
    - cscope        - application for interactively examining C or C++ source
                      code that can generate file that Vim can read, parse and
                      use, preferably version 15.9 or newer,
    - CMake         - application for generating build system files, to be
                      able to build your project.

==============================================================================
API                                                            *cxx-cmake:api*
==============================================================================

Settings Dictionary cxx-cmake implements Settings API (|proset:settings_api|).

                                                  *cxx-cmake:api:is_project()*
s:cxx_cmake.is_project()

Returns |cxx-cmake:cmake:settings:is_project|.

                                            *cxx-cmake:api:get_project_name()*
s:cxx_cmake.get_project_name()

Returns |cxx-cmake:cmake:settings:project_name|.

                                              *cxx-cmake:api:get_properties()*
s:cxx_cmake.get_properties()

Returns a dictionary with all the information cxx-cmake has. Forgive me for
not giving you all the information here. You can easily check what it has
using |ProsetGetProperties()|.

                                           *cxx-cmake:api:get_settings_name()*
s:cxx_cmake.get_settings_name()

Returns "cxx-cmake" string.

                                                      *cxx-cmake:api:enable()*
s:cxx_cmake.enable()

Enables cxx-cmake settings which include:

    - deleting |cxx-cmake:temporary:settings:temporary_directory| if for some
      reason one was there,
    - creating new |cxx-cmake:temporary:settings:temporary_directory|,
    - setting |'makeprg'| option to CMake command used to build project,
    - adding commands,
    - adding mappings,
    - setting paths to tags files in the 'tags' option,
    - generating tags file,
    - generating cscope file,
    - adding cscope (connections to) files,
    - updating |'path'| option.

                                                     *cxx-cmake:api:disable()*
s:cxx_cmake.disable()

Disables cxx-cmake settings (reverts enable()) which include:

    - restoring |'path'|, |'tags'| and |'makeprg'| options to the original
      values,
    - removing all cscope connections,
    - removing mappings,
    - removing commands,
    - deleting temporary directory.

                                                      *cxx-cmake:api:create()*
s:cxx_cmake.create(project_path, args)

Creates cxx-cmake project. Refer to |cxx-cmake:create_project| and to
|proset:settings_api:create()| to get everything you need to know.

                                                         *CXXCMakeConstruct()*
CXXCMakeConstruct(config, options)

Constructor of cxx-cmake Settings Dictionary. It is registered in the call to
ProsetRegisterSettings() function in an autocmd. It can also be used when you
want to extend cxx-cmake by writing your own Settings Dictionary and to have
cxx-cmake Settings Object as "member" in your type (extend of cxx-cmake).

Parameters differ depending on call type, so for:

    - Load:
        - a:config parameter is a configuration dictionary created after
          parsing configuration file,
        - a:options.mode is set to "load".

    - Create:
        - a:config parameter is empty dictionary,
        - a:options.mode is set to "create".

==============================================================================
CONFIGURATION                                        *cxx-cmake:configuration*
==============================================================================

There is only one configuration file that is required by cxx-cmake, this is
|g:proset_settings_file| (JSON file). All parameters in it are optional
(except "proset_settings") - when missing, default (hardcoded) value will be
used.

Depending on the parameter itself, the functionality can behave in a default
manner ("build_directory" and "jobs" will have default values, so you can
build your project), or the functionality can be disabled (mappings are not
available if missing). There are also parameters that if present but empty
will take default value anyway.

There is a parameter type designed to store directory path. Value of such
parameter MUST translate (|simplify()|) to or below project root path,
otherwise it is treated as incorrect and default value will be taken. Value is
trimmed first.  Even though you can use for example '..' as a part of the
value in such parameters, it is rather advised against ('src/../src/xd' ->
'src/xd'). There is an information that the parameter is checked in the
description of it.

Configuration is stored in JSON format. Below is a simplified version of
cxx-cmake configuration file.

{

"proset_settings":                  "cxx-cmake",

"temporary":
{
    "settings":
    {
        "temporary_directory":      ".vim-proset_tmp"
    }
},

"build":
{
    "settings":
    {
        "build_directory":          "build",
        "jobs":                     "8"
    },
    "mappings":
    {
        "build":                    "mk",
        "clean":                    "<Leader>bc",
        "clean_and_build":          "<S-F10>"
    }
}

}

String values are surrounded by '"' and array values are in '[]'.

The structure of this configuration file is more or less as follows:

"module":
{
    "settings": { ... },
    "mappings": { ... }
}

Some of the modules will have only settings, some of them will have only
mappings and some of them will have both. Unless otherwise noted, every
mapping parameter that is missing makes corresponding functionality not to be
mapped at all.

Key mapping sequence in configuration can be anything that is valid key
sequence in Vim mapping (nnoremap, etc).  Although whitespace characters
before and after mapping are ignored, those in the middle will most likely
cause troubles, so a mapping:

    "build": " mk "

is fine, it is treated as:

    "build": "mk" 

but a mapping:

    "run": "m r"

is not. So, for any SPACE or TAB you want to use in your mapping, please use
appropriate placeholder: <SPACE> or <TAB>. Using this, we can write correct
mapping:

    "run": "m<SPACE>r"


Since structure of cxx-cmake is in module oriented fashion, description of
settings and mappings are stored in suitable documentation sections.

Note: Unless otherwise noted, all entries in (every) 'module.settings' are
taken from configuration file.

                                                   *cxx-cmake:proset_settings*
proset_settings

Mandatory parameter used by Proset plugin to determine what Settings Object
to choose.

Required value:
proset_settings: "cxx-cmake"

==============================================================================
CREATE PROJECT                                      *cxx-cmake:create_project*
==============================================================================

It would be very inconvenient if you would like to use cxx-cmake project but
you would be forced to prepare it manually by yourself or what is even worse
copy required files from already existing project. Do not worry, you are able
to create dummy cxx-cmake project very easily using |ProsetCreate| function or
command.

What does |cxx-cmake:api:create()| really do?

1) Determine project type

Received as optional argument in function call.  It can be "execute", "static"
or "shared" which respectively mean application, static library and shared
library. The only difference between those project types in generated sources
is CMakeLists.txt file.

2) Parse project name

It is simply name of the project root directory.

3) Create |cxx-cmake:source:settings:source_directory| in project root path
4) Create CMakeLists.txt file in project root path
5) Create main file with |cxx-cmake:source:settings:source_extension| in
   project root path
6) Return project name and dictionary with settings that will be written to
   |g:proset_settings_file| making it valid and loadable


                                              *cxx-cmake:create_project:usage*
So, to create cxx-cmake project, start Vim and enter following command (value
in square bracket is optional and if desired write it without []):

    :ProsetCreate cxx-cmake foo/boo [execute]

and Proset will invoke |cxx-cmake:api:create()| passing following arguments:

    - a:project_path is of course path to the directory where your project has
      to be created, here "foo/boo", creating "foo" if missing,

    - a:args is optional, separated by space list of additional data passed by
      user. For now there is only one supported:

        - project type - one of [execute, static, shared]. If missing,
          "execute" is taken. If any other value is used, then exception is
          thrown - refer to |ProsetCreate()| to see which error code you get.

==============================================================================
VARIABLES                                                *cxx-cmake:variables*
==============================================================================

                                                  *g:cxx_cmake_input_template*
If you have already created cxx-cmake project using ProsetCreate function or
command, you probably also saw that |g:proset_settings_file| uses some default
values that you may not like. If you wondered if there is some possible way to
be able to provide your own favourite defaults then I have good news for you -
you can, using this variable. This variable stores path to the template
|g:proset_settings_file|. Template supported by plugin is stored in
autoload/proset/settings/cxx_cmake/resources/cxx-cmake-template.json. Feel
free to copy it, modify as you like and change this variable to the place
where you store it.

To change default value, put this in your vimrc:

 let g:cxx_cmake_input_template = $HOME . "/cxx-cmake-template-foo.json"
 
If variable is not defined or defined but file is not readable then plugin
supported template is used. If file does not hold all configuration (it may
happen after plugin update and you have not updated template file) - default
hardcoded values will be used, some of them may have value (settings), some of
them may be empty (mappings). To be sure what value is used in such case refer
to following sections or look to the code.

==============================================================================
CMAKE                                                        *cxx-cmake:cmake*
==============================================================================

To build C or C++ code, you can enter compiler command directly on the command
line, like this:

    g++ -std=c++11 main.cpp -o main

which is ok if you have one or maybe couple files.

Another option is to use make command which expects to have Makefile file as
its input. So, you can write such Makefile which gathers all rules and
properties of the build process. It is basically typical solution in Linux
environment, but writing Makefile is not so easy.

Another - but not last of course - solution is to use CMake build system
generator which has its own input file CMakeLists.txt with its own language to
define rules and properties of the build process. Based on this input file it
can generate multiple different build system files - for example Makefile -
using available generators (see CMake generators for more information).
CMakeLists.txt has definition how to build project, but this is CMake job to
generate appropriate build system files on supported Operating System to make
your program compile.

------------------------------------------------------------------------------
Settings                                            *cxx-cmake:cmake:settings*
------------------------------------------------------------------------------

All following settings are not taken from configuration file, they are
calculated internally by cmake.vim module file.

                                         *cxx-cmake:cmake:settings:input_file*
The input file for CMake is CMakeLists.txt, which is placed in the project
root.

                                       *cxx-cmake:cmake:settings:project_name*
Although I tried not to force users to provide lot of dependencies (there are
very few, see |cxx-cmake:dependencies|), neither force them to change their
setup, but there is one thing that has to be done in CMakeLists.txt to make
cxx-cmake work. CMakeLists.txt has to define PROJECT_NAME variable, i.e.:

    set(PROJECT_NAME "foo192")

in which project name has to be in double quote. This name is used as build
result name (application, library). If there is no such variable defined,
empty string is set.

                                      *cxx-cmake:cmake:settings:bin_directory*
Another - but optional - thing is the definition of one of the following CMake
variables:

    - CMAKE_RUNTIME_OUTPUT_DIRECTORY - for application,
    - CMAKE_ARCHIVE_OUTPUT_DIRECTORY - for static library,
    - CMAKE_LIBRARY_OUTPUT_DIRECTORY - for shared library.

It means that you can specify output (bin) directory for your application or
library. If you do not specify the path, then result of your build will be
placed in |cxx-cmake:build:settings:build_directory|. You can change your
output directory using these variables like this:

1) Application will be in project_root/bin/

    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_SOURCE_DIR}/bin")

2) Static library will be in |cxx-cmake:build:settings:build_directory|/bin/

    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "bin")

                                         *cxx-cmake:cmake:settings:is_project*
If |ProsetIsProject()| returns TRUE then cxx-cmake can be used (we are in the
project), otherwise it can not be used (we are not in the project). To make it
return TRUE, all of the following conditions have to be TRUE:

    - CMakeLists.txt is in the project root (current directory) and can be
      read,
    - |cxx-cmake:source:settings:source_directory| exists,
    - |g:proset_settings_file| can be read,
    - PROJECT_NAME variable is defined in CMakeLists.txt and is not empty.

==============================================================================
TEMPORARY                                                *cxx-cmake:temporary*
==============================================================================

For cxx-cmake to work correctly (ctags and cscope), some temporary files have
to be created.  This section has information about temporary things.

------------------------------------------------------------------------------
Settings                                        *cxx-cmake:temporary:settings*
------------------------------------------------------------------------------

                            *cxx-cmake:temporary:settings:temporary_directory*
Directory where cscope and ctags temporary (generated) symbols files will be
stored.

If missing, empty or incorrect:
"temporary":
{
    "settings":
    {
        "temporary_directory": ".vim-proset_tmp"
    }
}

==============================================================================
SOURCE                                                      *cxx-cmake:source*
==============================================================================

Properties of source code are presented here.

------------------------------------------------------------------------------
Settings                                           *cxx-cmake:source:settings*
------------------------------------------------------------------------------

                                  *cxx-cmake:source:settings:source_directory*
Source directory where all C/C++ files are placed.

If missing, empty or incorrect:
"source":
{
    "settings":
    {
        "source_directory": "src"
    }
}

                                  *cxx-cmake:source:settings:header_extension*
Extension for header file when creating file using cxx-cmake commands. This is
also used for alternate-file module (switching between header and source
files).

If missing or empty:
"source":
{
    "settings":
    {
        "header_extension": "hpp"
    }
}

                                  *cxx-cmake:source:settings:source_extension*
Extension for source file when creating file using cxx-cmake commands. This is
also used for alternate-file module (switching between header and source
files).

If missing or empty:
"source":
{
    "settings":
    {
        "source_extension": "cpp"
    }
}

                     *cxx-cmake:source:settings:additional_search_directories*
This is a list of additional paths to directories which will be appended to
|'path'|. You can specify one or more, in both cases put them in the array.

Example:
"source":
{
    "settings":
    {
        "additional_search_directories": [ "../", "target/" ]
    }
}

If missing:
"source":
{
    "settings":
    {
        "additional_search_directories": []
    }
}

==============================================================================
BUILD                                                        *cxx-cmake:build*
==============================================================================

One of the key functionalities of cxx-cmake is to build your project directly
from Vim. Build process is done in the background, which means without loosing
ability to move around and doing other things.

You have several options at your disposal:

                                                       *cxx-cmake:build:build*
Build process is defined by CMakeLists.txt file and it uses CMake to do the
job using |AsyncRun| plugin. Automatically output of build process is loaded
in QuickFix window. If build is success, then QuickFix window is closed
automatically. If warning or error is detected, QuickFix window is left open.

All build files are put into |cxx-cmake:build:settings:build_directory|
directory. Location of build result (application, library) depends on
configuration in CMakeLists.txt (not in configuration file of cxx-cmake!).
For more information see |cxx-cmake:cmake:settings:bin_directory|.

To build project use command or mapping:

command: *:CXXCMakeBuild*
mapping: |cxx-cmake:build:mappings:build|

                                                       *cxx-cmake:build:clean*
You may want just to remove |cxx-cmake:build:settings:build_directory|
directory which stores all previous build files (object files, CMake temporary
files, build result). 

To do so, use command or mapping:

command: *:CXXCMakeClean*
mapping: |cxx-cmake:build:mappings:clean|

                                             *cxx-cmake:build:clean_and_build*
To get rid of previous build files (object files, CMake temporary files, build
result) and to build your project from scratch you do not have to remove build
directory manually and then build project. You may want to use command or
mapping that is designed for that.

To build your project from scratch then, use command or mapping:

command: *:CXXCMakeCleanAndBuild*
mapping: |cxx-cmake:build:mappings:clean_and_build|

------------------------------------------------------------------------------
Settings                                            *cxx-cmake:build:settings*
------------------------------------------------------------------------------

                                    *cxx-cmake:build:settings:build_directory*
Directory for build files (CMake build files, objects *.o, etc).

If missing, empty or incorrect:
"build":
{
    "settings":
    {
        "build_directory": "build"
    }
}

                                               *cxx-cmake:build:settings:jobs*
Maximum number of jobs used to build your project (building in parallel). If
you want single job to be used to build your project, set value of 1. If this
parameter has empty value then maximum number of jobs will be used.

For maximum number of jobs:
"build":
{
    "settings":
    {
        "jobs": ""
    }
}

If missing:
"build":
{
    "settings":
    {
        "jobs": "1"
    }
}

------------------------------------------------------------------------------
Mappings                                            *cxx-cmake:build:mappings*
------------------------------------------------------------------------------

                                              *cxx-cmake:build:mappings:build*
Mapping for building the project.

Example:
"build":
{
    "mappings":
    {
        "build": "mk"
    }
}

                                              *cxx-cmake:build:mappings:clean*
Mapping for cleaning the project.

Example:
"build":
{
    "mappings":
    {
        "clean": "mC"
    }
}

                                    *cxx-cmake:build:mappings:clean_and_build*
Mapping for cleaning and building the project.

Example:
"build":
{
    "mappings":
    {
        "clean_and_build": "mK"
    }
}

==============================================================================
RUN                                                            *cxx-cmake:run*
==============================================================================

Another very important functionality of cxx-cmake is to run your application
from Vim (inside terminal). You have two options, first one is to run without
arguments, and the other one is to run with them. So, after build is
completed, use one of the following commands or mappings to do what you want.

To run your application without arguments, use command or mapping:

command: *:CXXCMakeRun*
mapping: |cxx-cmake:run:mappings:run|

And with arguments:

command: *:CXXCMakeRun* arg1 arg2 ...
mapping: |cxx-cmake:run:mappings:run_args|

------------------------------------------------------------------------------
Mappings                                              *cxx-cmake:run:mappings*
------------------------------------------------------------------------------

                                                  *cxx-cmake:run:mappings:run*
Mapping for running the project without arguments.

Example:
"run":
{
    "mappings":
    {
        "run": "mr"
    }
}

                                             *cxx-cmake:run:mappings:run_args*
Mapping for running the project with arguments.

Example:
"run":
{
    "mappings":
    {
        "run_args": "mR"
    }
}

==============================================================================
ALTERNATE FILE                                      *cxx-cmake:alternate_file*
==============================================================================

When writing or reading C/C++ code you will see that there are two types of
files: header (declaration) and source (definition). These files have
different extensions, respectively: h, hpp, hxx, hh, H (or even others) and c,
cpp, cxx, cc, C (or even others). Switching rapidly between header and source
files is very important and it is available using following mappings or
commands.  For now it only works if both files are in the same directory.
Also, this functionality does not create alternate file if it is missing.

                                     *cxx-cmake:alternate_file:current_window*
To switch from header to source or vice versa and load alternate file in a
current window, use any of those:

command: *:CXXCMakeAlternateFileCurrentWindow*
mapping: |cxx-cmake:alternate_file:mappings:current_window|

                                       *cxx-cmake:alternate_file:split_window*
To switch from header to source or vice versa and load alternate file in a
split window, use any of those:

command: *:CXXCMakeAlternateFileSplitWindow*
mapping: |cxx-cmake:alternate_file:mappings:split_window|

                                      *cxx-cmake:alternate_file:vsplit_window*
To switch from header to source or vice versa and load alternate file in a
vsplit window, use any of those:

command: *:CXXCMakeAlternateFileVSplitWindow*
mapping: |cxx-cmake:alternate_file:mappings:vsplit_window|

------------------------------------------------------------------------------
Mappings                                   *cxx-cmake:alternate_file:mappings*
------------------------------------------------------------------------------

                            *cxx-cmake:alternate_file:mappings:current_window*
Mapping for switching between header and source files (in current window).

Example:
"alternate_file":
{
    "mappings":
    {
        "current_window": "ma"
    }
}

                              *cxx-cmake:alternate_file:mappings:split_window*
Mapping for switching between header and source files (in split window).

Example:
"alternate_file":
{
    "mappings":
    {
        "split_window": "mA"
    }
}

                             *cxx-cmake:alternate_file:mappings:vsplit_window*
Mapping for switching between header and source files (in vsplit window).

Example:
"alternate_file":
{
    "mappings":
    {
        "vsplit_window": "mz"
    }
}

==============================================================================
CREATE HEADER                                        *cxx-cmake:create_header*
==============================================================================

When writing C/C++ code, you will need to create header files. Header file
should have include guard (#ifndef, #define, #endif). You could create foo.hpp
without a problem, but writing include guard on your own every single time is
waste of time and energy. This should be done automatically when you create
header file and this functionality does that.

To create header file you have couple options:

                                              *cxx-cmake:create_header:create*
Create header

command: *:CXXCMakeCreateHeader*
mapping: |cxx-cmake:create_header:mappings:create|

                                         *cxx-cmake:create_header:create_edit*
Create header and edit in a current window

command: *:CXXCMakeCreateHeaderEdit*
mapping: |cxx-cmake:create_header:mappings:create_edit|

                                   *cxx-cmake:create_header:create_edit_split*
Create header and edit in a split window

command: *:CXXCMakeCreateHeaderEditSplit*
mapping: |cxx-cmake:create_header:mappings:create_edit_split|

                                  *cxx-cmake:create_header:create_edit_vsplit*
Create header and edit in a vsplit window

command: *:CXXCMakeCreateHeaderEditVSplit*
mapping: |cxx-cmake:create_header:mappings:create_edit_vsplit|

Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the file you want to create without
extension (but if you pass it, it will be removed and what extension will be
used is defined by |cxx-cmake:source:settings:header_extension|). Any missing
directory in the hierarchy will be created.

Note: All of the above commands will emit CXXCMakeHeaderCreatedEvent if the
file was created.

Include guard is a string in the form of:

    PN_D1_D2_D3_F_EXT

where:
    PN          - project name taken from |cxx-cmake:api:get_project_name()|,
    D1, D2, D3  - D1/D2/D3 path to the file F,
    F           - filename,
    EXT         - extension of the file F taken from
                  |cxx-cmake:source:settings:header_extension|

example:
    FOO1_SRC_BOO_FOO_BLA_HPP

src/boo/foo/bla.hpp in foo1 project.

Usage example:
    :CXXCMakeCreateHeader src/boo/foo/bla

will create bla.hpp file (if hpp is header extension in configuration) in the
src/boo/foo directory hierarchy (creating directories if needed) whose content
looks like this:

    #ifndef FOO1_SRC_BOO_FOO_BLA_HPP
    #define FOO1_SRC_BOO_FOO_BLA_HPP


    #endif // FOO1_SRC_BOO_FOO_BLA_HPP

------------------------------------------------------------------------------
Mappings                                    *cxx-cmake:create_header:mappings*
------------------------------------------------------------------------------

                                     *cxx-cmake:create_header:mappings:create*
Mapping for creating (only) header file.

Example:
"create_header":
{
    "mappings":
    {
        "create": "mhc"
    }
}

                                *cxx-cmake:create_header:mappings:create_edit*
Mapping for creating and editing header file in current window.

Example:
"create_header":
{
    "mappings":
    {
        "create_edit": "mhe"
    }
}

                          *cxx-cmake:create_header:mappings:create_edit_split*
Mapping for creating and editing header file in split window.

Example:
"create_header":
{
    "mappings":
    {
        "create_edit_split": "mhi"
    }
}

                         *cxx-cmake:create_header:mappings:create_edit_vsplit*
Mapping for creating and editing header file in vsplit window.

Example:
"create_header":
{
    "mappings":
    {
        "create_edit_vsplit": "mhv"
    }
}

==============================================================================
CREATE SOURCE                                        *cxx-cmake:create_source*
==============================================================================

Besides header files, you will also create source files. Source file does not
have any include guard, but very often it includes header file using #include
directive. To make life just a little bit more comfortable - even if it is not
a big deal - this #include directive is inserted automatically by following
commands.

To create source file you have couple options:

                                              *cxx-cmake:create_source:create*
Create source

command: *:CXXCMakeCreateSource*
mapping: |cxx-cmake:create_source:mappings:create|

                                         *cxx-cmake:create_source:create_edit*
Create source and edit in a current window

command: *:CXXCMakeCreateSourceEdit*
mapping: |cxx-cmake:create_source:mappings:create_edit|

                                   *cxx-cmake:create_source:create_edit_split*
Create source and edit in a split window

command: *:CXXCMakeCreateSourceEditSplit*
mapping: |cxx-cmake:create_source:mappings:create_edit_split|

                                  *cxx-cmake:create_source:create_edit_vsplit*
Create source and edit in a vsplit window

command: *:CXXCMakeCreateSourceEditVSplit*
mapping: |cxx-cmake:create_source:mappings:create_edit_vsplit|

Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the file you want to create without
extension (but if you pass it, it will be removed and what extension will be
used is defined by |cxx-cmake:source:settings:source_extension|). Any missing
directory in the hierarchy will be created.

Note: All of the above commands will emit CXXCMakeSourceCreatedEvent if the
file was created.

Usage example:
    :CXXCMakeCreateSourceEdit src/boo/foo/bla

will create bla.cpp file (if cpp is source extension in configuration) in the
src/boo/foo directory hierarchy (creating directories if needed) whose content
looks like this:

    #include "bla.hpp"

additionally, file will be opened in a current window.

Note: For now, including header file is from the same directory as source
file.

------------------------------------------------------------------------------
Mappings                                    *cxx-cmake:create_source:mappings*
------------------------------------------------------------------------------

                                     *cxx-cmake:create_source:mappings:create*
Mapping for creating (only) source file.

Example:
"create_source":
{
    "mappings":
    {
        "create": "msc"
    }
}

                                *cxx-cmake:create_source:mappings:create_edit*
Mapping for creating and editing source file in current window.

Example:
"create_source":
{
    "mappings":
    {
        "create_edit": "mse"
    }
}

                          *cxx-cmake:create_source:mappings:create_edit_split*
Mapping for creating and editing source file in split window.

Example:
"create_source":
{
    "mappings":
    {
        "create_edit_split": "msi"
    }
}

                         *cxx-cmake:create_source:mappings:create_edit_vsplit*
Mapping for creating and editing source file in vsplit window.

Example:
"create_source":
{
    "mappings":
    {
        "create_edit_vsplit": "msv"
    }
}

==============================================================================
CREATE HEADER AND SOURCE                      *cxx-cmake:create_header_source*
==============================================================================

Create header and source files can be done at one step. Use any of the
following commands to achvieve that.

To create header and source files you have couple options:

                                       *cxx-cmake:create_header_source:create*
Create header and source

command: *:CXXCMakeCreateHeaderSource*
mapping: |cxx-cmake:create_header_source:mappings:create|

                            *cxx-cmake:create_header_source:create_edit_split*
Create header and source and edit in split windows

command: *:CXXCMakeCreateHeaderSourceEditSplit*
mapping: |cxx-cmake:create_header_source:mappings:create_edit_split|

                    *cxx-cmake:create_header_source:create_edit_current_split*
Create header and source and edit in current and split window

command: *:CXXCMakeCreateHeaderSourceEditCurrentSplit*
mapping: |cxx-cmake:create_header_source:mappings:create_edit_current_split|

                           *cxx-cmake:create_header_source:create_edit_vsplit*
Create header and source and edit in vsplit windows

command: *:CXXCMakeCreateHeaderSourceEditVSplit*
mapping: |cxx-cmake:create_header_source:mappings:create_edit_vsplit|

                   *cxx-cmake:create_header_source:create_edit_current_vsplit*
Create header and source and edit in current and vsplit window

command: *:CXXCMakeCreateHeaderSourceEditCurrentVSplit*
mapping: |cxx-cmake:create_header_source:mappings:create_edit_current_vsplit|

Except from Create Header and Create Source, you can not create and edit both
files in the same window, which is pretty much understandable, that is why,
you have option to open them in split or vsplit windows. You can also use
current window for header file and new split or vsplit window for source file.

Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the files without extension* you want to
create. Any missing directory in the hierarchy will be created.

*) name for both files is the same except from extension. If you pass
extension on the other hand, it will be removed and extensions will be used as
they are defined in:

    - |cxx-cmake:source:settings:header_extension|,
    - |cxx-cmake:source:settings:source_extension|.

Note: All of the above commands will emit CXXCMakeHeaderCreatedEvent if header
file was created and CXXCMakeSourceCreatedEvent if source file was created.

------------------------------------------------------------------------------
Mappings                             *cxx-cmake:create_header_source:mappings*
------------------------------------------------------------------------------

                              *cxx-cmake:create_header_source:mappings:create*
Mapping for creating (only) header and source files.

Example:
"create_header_source":
{
    "mappings":
    {
        "create": "mhsc"
    }
}

                   *cxx-cmake:create_header_source:mappings:create_edit_split*
Mapping for creating and editing header and source files in split windows
leaving current window untouched.

Example:
"create_header_source":
{
    "mappings":
    {
        "create_edit_split": "mhsi"
    }
}

           *cxx-cmake:create_header_source:mappings:create_edit_current_split*
Mapping for creating and editing header and source files in current and split
window.

Example:
"create_header_source":
{
    "mappings":
    {
        "create_edit_current_split": "mhsI"
    }
}

                  *cxx-cmake:create_header_source:mappings:create_edit_vsplit*
Mapping for creating and editing header and source files in vsplit windows
leaving current window untouched.

Example:
"create_header_source":
{
    "mappings":
    {
        "create_edit_vsplit": "mhsv"
    }
}

          *cxx-cmake:create_header_source:mappings:create_edit_current_vsplit*
Mapping for creating and editing header and source files in current and vsplit
window.

Example:
"create_header_source":
{
    "mappings":
    {
        "create_edit_current_vsplit": "mhsV"
    }
}

==============================================================================
SYMBOLS                                                    *cxx-cmake:symbols*
==============================================================================

To easily navigate through the source code of your project and possibly
external source code (for example: libraries) ctags and cscope applications
are used by cxx-cmake. These applications are well known and that is why it
should not be a big problem to make them available in your system. Ctags
generates tags file and cscope generates symbols cross-reference file. Both of
them will be referred as symbols database.

To use Vim tags module you need to generate tags file and update |'tags'|
option to point to it.  To use cscope you need to have Vim compiled with
+cscope module (you can find it in |:version|) and then generate cscope
symbols file and connect it to the cscope module using |:cs| add command.

In cxx-cmake these tedious and boring tasks are done automatically not to
bother you every single time you start Vim or load cxx-cmake Settings Object.

                                            *cxx-cmake:symbols:update_symbols*
When cxx-cmake Settings Object is loaded and we are in the project
(|ProsetIsProject()|, |cxx-cmake:api:is_project()|) |cxx-cmake:api:enable()|
is invoked which does all necessary things to make ctags and cscope symbols be
available in Vim. State of the symbols database is on |cxx-cmake:api:enable()|
time point.  If you add new or modify current source files later, then your
new symbols will most likely not be visible until you regenerate symbols
database (here both ctags and cscope, you can also do it separately). For now,
this has to be done manually using either command or a mapping.

command: *:CXXCMakeUpdateSymbols*
mapping: |cxx-cmake:symbols:mappings:update_symbols|

------------------------------------------------------------------------------
Mappings                                          *cxx-cmake:symbols:mappings*
------------------------------------------------------------------------------

                                   *cxx-cmake:symbols:mappings:update_symbols*
Mapping for updating ctags and cscope symbols manually.  Useful when your
sources have been changed (add new files, modify existing files). New symbols
are not visible before updating symbols database.

Example:
"symbols":
{
    "mappings":
    {
        "update_symbols": "mu"
    }
}

==============================================================================
CTAGS                                                        *cxx-cmake:ctags*
==============================================================================

In |cxx-cmake:api:enable()| first step is to set Vim option |'tags'| to have
appropriate values (paths):

    - *cxx-cmake:ctags:ctags_file* - path to the ctags symbols file, set to
      |cxx-cmake:temporary:settings:temporary_directory|/ctags,
    - |cxx-cmake:ctags:settings:external_ctags_files| - list of paths to
      already generated (not by cxx-cmake) ctags symbols files most likely
      for some external sources.

Second step is to generate ctags symbols (tags) file from:

    - |cxx-cmake:source:settings:source_directory| - directory with source
      code of your project,
    - |cxx-cmake:ctags:settings:additional_ctags_directories| - list of paths
      to the directories where some other source code lays.

For both of them, ctags symbols will be generated every time you start Vim,
load cxx-cmake Settings Object, or update them manually.  If you have files
that do not change too often and want to be able to navigate to the symbols
defined there, consider generation of ctags symbols once and add path to
generated file(s) in |cxx-cmake:ctags:settings:external_ctags_files| (for
performance reason).

To update ctags symbols manually, you can use either command or mapping.

command: *:CXXCMakeUpdateCtagsSymbols*
mapping: |cxx-cmake:ctags:mappings:update_ctags_symbols|

Usage in short: |CTRL-]| jumps to the tag, |CTRL-T|/|CTRL-O| goes back.
See |tags| to get more information about tags.

------------------------------------------------------------------------------
Settings                                            *cxx-cmake:ctags:settings*
------------------------------------------------------------------------------

                       *cxx-cmake:ctags:settings:additional_ctags_directories*
To generate tags file using ctags application you have to specify what source
code directory is going to be parsed.  Using cxx-cmake this is done
automatically for |cxx-cmake:source:settings:source_directory| (parsing
project source code). To parse even more source code (possibly some external
code that may change rather more than less often), put these directories
(either one or more) in the array.

Example:
"ctags":
{
    "settings":
    {
        "additional_ctags_directories": [ "../xd", "target/my_lib" ]
    }
}

If missing:
"ctags":
{
    "settings":
    {
        "additional_ctags_directories": []
    }
}

                               *cxx-cmake:ctags:settings:external_ctags_files*
To use external tags file (already generated, very rarely changing, for
example: standard C or C++ library), you are able to put its path here.
Use array to specify one or more files.

Example:
"ctags":
{
    "settings":
    {
        "external_ctags_files": [ "/tmp/ctags"]
    }
}

If missing:
"ctags":
{
    "settings":
    {
        "external_ctags_files": []
    }
}

Note:

When you generate ctags file of some "external" source code, keep in mind that
paths to the symbols in that file can be absolute or relative to the place
from which ctags command was run. Ctags file with absolute paths can be copied
to any place but ctags file with relative paths can not be.

Example commands to generate ctags file (absolute and relative paths):

 $ ctags -R --c++-kinds=+p --fields=+iaS --extras=+q -f ctags-abs $(pwd)/src
 $ ctags -R --c++-kinds=+p --fields=+iaS --extras=+q -f ctags-rel src


------------------------------------------------------------------------------
Mappings                                            *cxx-cmake:ctags:mappings*
------------------------------------------------------------------------------

                               *cxx-cmake:ctags:mappings:update_ctags_symbols*
Mapping for updating ctags symbols manually.

Example:
"ctags":
{
    "mappings":
    {
        "update_ctags_symbols": "mut"
    }
}

==============================================================================
CSCOPE                                                      *cxx-cmake:cscope*
==============================================================================

In |cxx-cmake:api:enable()| first step is to generate cscope symbols file
from:

    - |cxx-cmake:source:settings:source_directory| - directory with source
      code of your project,
    - |cxx-cmake:cscope:settings:additional_cscope_directories| - list
      of paths to the directories where some other source code lays.

For both of them, cscope symbols will be generated every time you start Vim,
load cxx-cmake Settings Object, or update them manually. If you have files
that do not change too often and want to be able to navigate to the symbols
defined there, consider generation of cscope symbols once and add path to
generated file(s) in |cxx-cmake:cscope:settings:external_cscope_files| (for
performance reason).

Second step is to connect cscope symbols files to Vim cscope module using
|:cs| add command. These files are:

    - *cxx-cmake:cscope:cscope_file* - path to the cscope symbols file, set to
      |cxx-cmake:temporary:settings:temporary_directory|/cscope,
    - |cxx-cmake:cscope:settings:external_cscope_files| - list of paths to
      already generated (not by cxx-cmake) cscope symbols files most likely
      for some external sources.

To update cscope symbols manually, you can use either command or mapping.

command: *:CXXCMakeUpdateCscopeSymbols*
mapping: |cxx-cmake:cscope:mappings:update_cscope_symbols|

You have two options how to use cscope in Vim with cxx-cmake:

    - use Vim cscope commands,
    - use cxx-cmake mappings (shortcut for above).

Using cscope command you have to provide name you want to search for. For
mapping there is an assumption it uses <cword> (word under the cursor as a
name). All of these mappings work in normal mode.

command: :cs find a name
mapping: |cxx-cmake:cscope:mappings:a_assignments|

command: :cs find c name
mapping: |cxx-cmake:cscope:mappings:c_functions_calling|

command: :cs find d name
mapping: |cxx-cmake:cscope:mappings:d_functions_called_by|

command: :cs find e name
mapping: |cxx-cmake:cscope:mappings:e_egrep|

command: :cs find f name
mapping: |cxx-cmake:cscope:mappings:f_file|

command: :cs find g name
mapping: |cxx-cmake:cscope:mappings:g_definition|

command: :cs find i name
mapping: |cxx-cmake:cscope:mappings:i_including|

command: :cs find s name
mapping: |cxx-cmake:cscope:mappings:s_symbol|

command: :cs find t name
mapping: |cxx-cmake:cscope:mappings:t_string|

See |cscope| to get more information how to use it.

------------------------------------------------------------------------------
Settings                                           *cxx-cmake:cscope:settings*
------------------------------------------------------------------------------

                     *cxx-cmake:cscope:settings:additional_cscope_directories*
In cxx-cmake, cscope application is used to generate cscope symbols file, by
default it uses |cxx-cmake:source:settings:source_directory|. If you want to
parse source code from different directories as well, then this parameter is
for that. You may specify one or more paths to (external) source directories,
in both cases use array.

Example:
"cscope":
{
    "settings":
    {
        "additional_cscope_directories": [ "../xd", "target/my_lib" ]
    }
}

If missing:
"cscope":
{
    "settings":
    {
        "additional_cscope_directories": []
    }
}

                             *cxx-cmake:cscope:settings:external_cscope_files*
To use external cscope symbols file (already generated, very rarely changing,
for example: standard C or C++ library), you are able to put its path here.
Use array to specify one or more files.

Example:
"cscope":
{
    "settings":
    {
        "external_cscope_files": [ "/tmp/cscopeX", "/tmp/cscope2" ]
    }
}

If missing:
"cscope":
{
    "settings":
    {
        "external_cscope_files": []
    }
}

NOTE:

When you generate cscope file of some "external" source code, keep in mind
that paths to the symbols in that file can be absolute or relative to the
place from which cscope command was run. In contrast to ctags file, cscope
file with relative paths will not work, you have to generate file with
absolute paths.

Example commands to generate cscope file (absolute and relative paths):

 $ cscope -Rb -f cscope-abs $(pwd)/src/*
 $ cscope -Rb -f cscope-rel src/*


------------------------------------------------------------------------------
Mappings                                           *cxx-cmake:cscope:mappings*
------------------------------------------------------------------------------

                             *cxx-cmake:cscope:mappings:update_cscope_symbols*
Mapping for updating cscope symbols manually.

Example:
"cscope":
{
    "mappings":
    {
        "update_cscope_symbols": "muc"
    }
}

                                     *cxx-cmake:cscope:mappings:a_assignments*
Mapping for searching symbol using cscope querytype a(9): "Find places where
this symbol is assigned a value".

Example:
"cscope":
{
    "mappings":
    {
        "a_assignments": "mea"
    }
}

                               *cxx-cmake:cscope:mappings:c_functions_calling*
Mapping for searching symbol using cscope querytype c(3): "Find functions
calling this function".

Example:
"cscope":
{
    "mappings":
    {
        "c_functions_calling": "mec"
    }
}

                             *cxx-cmake:cscope:mappings:d_functions_called_by*
Mapping for searching symbol using cscope querytype d(2): "Find functions
called by this function".

Example:
"cscope":
{
    "mappings":
    {
        "d_functions_called_by": "med"
    }
}

                                           *cxx-cmake:cscope:mappings:e_egrep*
Mapping for searching symbol using cscope querytype e(6): "Find this egrep
pattern".

Example:
"cscope":
{
    "mappings":
    {
        "e_egrep": "mee"
    }
}

                                            *cxx-cmake:cscope:mappings:f_file*
Mapping for searching symbol using cscope querytype f(7): "Find this file".

Example:
"cscope":
{
    "mappings":
    {
        "f_file": "mef"
    }
}

                                      *cxx-cmake:cscope:mappings:g_definition*
Mapping for searching symbol using cscope querytype g(1): "Find this
definition".

Example:
"cscope":
{
    "mappings":
    {
        "g_definition": "meg"
    }
}

                                       *cxx-cmake:cscope:mappings:i_including*
Mapping for searching symbol using cscope querytype i(8): "Find files
#including this file".

Example:
"cscope":
{
    "mappings":
    {
        "i_including": "mei"
    }
}

                                          *cxx-cmake:cscope:mappings:s_symbol*
Mapping for searching symbol using cscope querytype s(0): "Find this C
symbol".

Example:
"cscope":
{
    "mappings":
    {
        "s_symbol": "mes"
    }
}

                                          *cxx-cmake:cscope:mappings:t_string*
Mapping for searching symbol using cscope querytype t(4): "Find this text
string".

Example:
"cscope":
{
    "mappings":
    {
        "t_string": "met"
    }
}

==============================================================================
DERIVATIVES (CXX-CMAKE-AP)                             *cxx-cmake:derivatives*
==============================================================================

Imagine a little bit:

So, you look at the cxx-cmake Settings Dictionary and you consider it to be
good, but not exactly for your needs, it is close, yet not completed.

    - Why the author didn't do some integration with my favourite filesystem
      explorer NERDTree?
    - Why there are no mappings or commands for snippets plugin?
    - Why there is no autocompletion engine involved?
    - and so on...

All C++ programmers would benefit from it, wouldn't they?

Answer:

Well, not exactly, your needs are your needs, not mine or other people.
People like to have their own setup and not to be forced to use something they
don't like or want. That is why I tried to make cxx-cmake Settings Dictionary
as much general as possible with a little few dependencies. Except AsyncRun,
all Vim dependencies should rather be easily met. Since cxx-cmake is the name,
CMake became natural dependency for it. Maybe AsyncRun dependency will be
removed in a future and cxx-cmake will take care of asynchronous task on its
own, but for now it stays, sorry if this makes you angry.

But I have good news for you! You can extend cxx-cmake and make your own
cxx-cmake-ap Settings Dictionary (or choose other, better name) that you will
register in the Proset plugin and this is not as hard as you may initially
think. I hope, you have already read |proset:settings_dictionary| because
there are informations how to do it. Yet, I will give you complete example
anyway.

I did not say that cxx-cmake will never have support for external plugins as
weak dependencies (if plugin is available -> cxx-cmake module is available).
It is possible, it may happen. I think that support for external plugins seems
to be rather supported directly by Proset not by any Settings Dictionary (do
this once, not multiple times), but this idea has to be considered well and
this is for future release if at all.

Example:

Some people like NERDTree filesystem explorer, some people don't, because they
prefer to use fuzzy-finder plugins. If you are in the first group, you may
have noticed that when you use any of CXXCMakeCreate* command, NERDTree window
is not updated and you do not see newly created files immediately. To see them
you have to refresh NERDTree window manually, which of course is a little bit
annoying.

So let's get started to get it done automatically.

 if exists("g:loaded_proset_settings_cxx_cmake_ap")
     finish
 endif
 let g:loaded_proset_settings_cxx_cmake_ap = 1
 
 " (1)
 runtime plugin/settings/cxx_cmake.vim
 
 let s:cxx_cmake_ap = {'properties': {}}
 
 " (2)
 function! s:cxx_cmake_ap.construct(config, options, settings_name)
     let l:ret = deepcopy(self)
     let l:ret.parent = CXXCMakeConstruct(a:config, a:options)
     let l:ret.properties.settings_name = a:settings_name
     return l:ret
 endfunction
 
 function! s:cxx_cmake_ap.is_project()
     return self.parent.is_project()
 endfunction
 
 function! s:cxx_cmake_ap.get_project_name()
     return self.parent.get_project_name()
 endfunction
 
 function! s:cxx_cmake_ap.get_properties()
     return self.parent.get_properties()
 endfunction
 
 function! s:cxx_cmake_ap.get_settings_name()
     return self.properties.settings_name
 endfunction
 
 " (3)
 function! s:cxx_cmake_ap.enable()
     call self.parent.enable()
     " (4)
     autocmd User CXXCMakeHeaderCreatedEvent :NERDTreeRefreshRoot
     autocmd User CXXCMakeSourceCreatedEvent :NERDTreeRefreshRoot
 endfunction
 
 function! s:cxx_cmake_ap.disable()
     autocmd! User CXXCMakeHeaderCreatedEvent
     autocmd! User CXXCMakeSourceCreatedEvent
     call self.parent.disable()
 endfunction
 
 " (5)
 function! s:cxx_cmake_ap.create(project_path, args)
     let l:ret = self.parent.create(a:project_path, a:args)
     " (6)
     let l:ret.dictionary.foo = {"settings": {}, "mappings": {}}
     return l:ret
 endfunction
 
 " (7)
 autocmd User ProsetRegisterSettingsEvent
     \ call ProsetRegisterSettings("cxx-cmake-ap", "CXXCMakeApConstruct")
 
 " (8)
 function! CXXCMakeApConstruct(config, options)
     if a:options.mode == "load"
         let l:config = a:config
     elseif a:options.mode == "create"
         " (9)
         let l:config =
         \ json_decode(join(readfile(g:cxx_cmake_input_template), "\n"))
     else
     endif
 
     return s:cxx_cmake_ap.construct(l:config, a:options, "cxx-cmake-ap")
 endfunction

Why does it look this way is explained in |proset:settings_dictionary| in more
details, but I have marked some places which now need to be explained:

    (1) - we are going to use CXXCMakeConstruct(), we have to have its
          definition already sourced,
    (2) - definition of a construct() "member function" which uses public
          cxx-cmake constructor function to create an object (parent),
    (3) - here is a code that does the job of refreshing NERDTree window.
          cxx-cmake Settings Object produces events when file was created:

              - CXXCMakeHeaderCreatedEvent - when header was created,
              - CXXCMakeSourceCreatedEvent - when source was created.

          So, we are connecting this event to the action of refreshing
          NERDTree.  Remember to revert all the side efects of enable() in
          disable() function,
    (4) - you can easily put those commands in your vimrc, but then you will
          probably have these connections always, not only when needed (the
          idea of Proset plugin),
    (5) - definition of function that is used to create cxx-cmake-ap project
          via ProsetCreate,
    (6) - if you want to extend data that are written to settings file, you
          can do it here, you can also choose different template file (9),
    (7) - register settings name and assign public constructor function to it,
    (8) - constructor function that has to take two parameters: configuration
          and options dictionaries.

Note:
In (7) and (8) settings name string is "cxx-cmake-ap" and it has to be
identical in both places! Internal constructor (2) takes string as third
argument which is settings name. This means that you can create multiple
Settings Objects from cxx-cmake-ap Settings Dictionary, just duplicate (7)
and (8) and fill them with appropriate settings name string.

Rest is up to you what you want to have in your cxx-cmake-ap Settings
Dictionary.  This is just an idea of what you can do. Feel free to experiment
with it. Enjoy.

==============================================================================
CONTRIBUTE                                              *cxx-cmake:contribute*
==============================================================================

If you see a bug, or something that can be improved, or have an idea of a new
entry in settings or mappings for any module, or have an idea of a new module,
just let me know via GitHub or email.

==============================================================================
 vim:tw=78:et:ft=help:norl:
