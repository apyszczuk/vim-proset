*cxx-cmake.txt*   CXX CMake Settings Dictionary                    *cxx-cmake*

   ██████╗██╗  ██╗██╗  ██╗       ██████╗███╗   ███╗ █████╗ ██╗  ██╗███████╗
  ██╔════╝╚██╗██╔╝╚██╗██╔╝      ██╔════╝████╗ ████║██╔══██╗██║ ██╔╝██╔════╝
  ██║      ╚███╔╝  ╚███╔╝ █████╗██║     ██╔████╔██║███████║█████╔╝ █████╗  
  ██║      ██╔██╗  ██╔██╗ ╚════╝██║     ██║╚██╔╝██║██╔══██║██╔═██╗ ██╔══╝  
  ╚██████╗██╔╝ ██╗██╔╝ ██╗      ╚██████╗██║ ╚═╝ ██║██║  ██║██║  ██╗███████╗
   ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝       ╚═════╝╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝

Author:     Artur Pyszczuk <apyszczuk@gmail.com>
License:    Same terms as Vim itself (see |license|)
Website:    https://github.com/apyszczuk/vim-proset

==============================================================================
TABLE OF CONTENTS

 1) INTRODUCTION                                      |cxx-cmake:introduction|
 2) ASSUMPTIONS                                        |cxx-cmake:assumptions|
 3) DEPENDENCIES                                      |cxx-cmake:dependencies|
 4) API                                                        |cxx-cmake:api|
 5) ALTERNATE FILE                                  |cxx-cmake:alternate_file|
 6) CREATE HEADER                                    |cxx-cmake:create_header|
 7) CREATE SOURCE                                    |cxx-cmake:create_source|
 8) CREATE HEADER AND SOURCE                  |cxx-cmake:create_header_source|
 9) BUILD                                                    |cxx-cmake:build|
10) RUN                                                        |cxx-cmake:run|
11) SYMBOLS                                                |cxx-cmake:symbols|
12) CTAGS                                                    |cxx-cmake:ctags|
13) CSCOPE                                                  |cxx-cmake:cscope|
14) CONFIGURATION                                             |cxx-cmake:conf|
15) DERIVATIVES (CXX-CMAKE-AP)                         |cxx-cmake:derivatives|
16) CMAKE                                                    |cxx-cmake:cmake|


==============================================================================
INTRODUCTION                                          *cxx-cmake:introduction*

Settings Dictionary |cxx-cmake| is supposed to be used when you want to write
C or C++ library or application using CMake as your build system.  Even though
CXX normally means C++, you are free to use it with C as well. All you have to
do is to change some entries in CMakeLists.txt and probably set header and
source files extensions in |proset:configuration:file| most likely to h and c.

Hopefully, you have already read |proset| documentation and you are familiar
with idea of Settings Dictionaries and Settings Objects in Proset plugin, if
not, go there first.

In short, when you use cxx-cmake Settings Object you will be able to (using
command or a mapping):

    - build project,
    - clean project,
    - clean and build project,
    - run project (if not a library),
    - navigate through the source code with ease thanks to cscope and ctags,
    - switch between header and source files very easily,
    - create header file with include guard macro defined,
    - create source file with #include header file,
    - create header and source files (at once).


==============================================================================
ASSUMPTIONS                                            *cxx-cmake:assumptions*

Just before we start, take a look:

    - each command starts with a colon ':' which means that in normal mode you
      type : and then name of a command (CXXCMake*),
    - each command ends with <CR> (enter/return),
    - if there is no explicit information that a command takes some arguments,
      then it takes 0 arguments,
    - tags in this document are in the form of cxx-cmake:section and some
      sections can be read as cxx-cmake:module, which means it is a module
      with functionalities.


==============================================================================
DEPENDENCIES                                          *cxx-cmake:dependencies*

To make cxx-cmake Settings Object work correctly (work at all), you have to
have following dependencies installed:

    - vim >= 8.0    - minimum version of Vim, (todo: check version)
    - +terminal     - support for inside terminal in Vim (|:version|),
    - +cscope       - support for cscope in Vim (|:version|)
    - asyncrun.vim  - plugin for running shell commands in the background and
                      read output in the quickfix window in realtime,
    - ctags         - application for generating tags file that Vim can read,
                      parse and use, preferably Universal Ctags 6.1.0 or
                      newer,
    - cscope        - application for interactively examining C or C++ source
                      code that can generate file that Vim can read, parse and
                      use, preferably version 15.9 or newer,
    - CMake         - application for generating build system files, to be
                      able to build your project.


==============================================================================
API                                                            *cxx-cmake:api*

Settings Dictionary cxx-cmake implements Settings API (|proset:settings_api|).

                                                  *cxx-cmake:api:is_project()*
s:cxx_cmake.is_project()

Returns TRUE if:

    - CMakeLists.txt is in the current directory and can be read, and
    - |cxx-cmake:conf:source.settings.source_directory| exists, and
    - |g:proset_settings_file| can be read, and
    - PROJECT_NAME variable is defined in CMakeLists.txt and is not empty.

otherwise returns FALSE.

                                            *cxx-cmake:api:get_project_name()*
s:cxx_cmake.get_project_name()

Returns value of CMakeLists.txt variable PROJECT_NAME:

    set(PROJECT_NAME "foo1")

If there is no such variable defined, empty string is returned.

                                              *cxx-cmake:api:get_properties()*
s:cxx_cmake.get_properties()

Returns a dictionary with all the information cxx-cmake has. Forgive me for
not giving you all the information here. You can easily check what it has
using |ProsetGetProperties()|.

                                           *cxx-cmake:api:get_settings_name()*
s:cxx_cmake.get_settings_name()

Returns "cxx-cmake" string.

                                                      *cxx-cmake:api:enable()*
s:cxx_cmake.enable()

Enables cxx-cmake settings which include:

    - deleting |cxx-cmake:conf:temporary.settings.temporary_directory| if for
      some reason one was there,
    - creating new |cxx-cmake:conf:temporary.settings.temporary_directory|,
    - setting |'makeprg'| option to CMake command used to build project,
    - adding commands,
    - adding mappings,
    - setting paths to tags files in the 'tags' option,
    - generating tags file,
    - generating cscope file,
    - adding cscope (connections to) files,
    - updating |'path'| option.

                                                     *cxx-cmake:api:disable()*
s:cxx_cmake.disable()

Disables cxx-cmake settings (reverts enable()) which include:

    - restoring |'path'|, |'tags'| and |'makeprg'| options to the original
      values,
    - removing all cscope connections,
    - removing mappings,
    - removing commands,
    - deleting temporary directory.

                                                         *CXXCMakeConstruct()*
CXXCMakeConstruct(config)

Constructor of cxx-cmake Settings Dictionary. It is registered in the call to
ProsetRegisterSettings() function in an autocmd. It can also be used when you
want to extend cxx-cmake by writing your own Settings Dictionary and to have
cxx-cmake Settings Object as "member" in your type (extend of cxx-cmake).

a:config parameter is a configuration dictionary you have to provide and you
can get it from |ProsetGetConfiguration()|.


==============================================================================
ALTERNATE FILE                                      *cxx-cmake:alternate_file*

When writing or reading C/C++ code you will see that there are two types of
files: header (declaration) and source (definition). These files have
different extensions, respectively: h, hpp, hxx, hh, H (or even others) and c,
cpp, cxx, cc, C (or even others). Switching rapidly between header and source
files is very important and it is available using following mappings or
commands.  For now it only works if both files are in the same directory.
Future plan is to be able to store headers and sources separately (in
different directories) and to make alternate-file module also work. Also, this
functionality does not create alternate file if it is missing.

                                     *cxx-cmake:alternate_file:current_window*
1) Alternate file in a current window

To switch from header to source or vice versa and load alternate file in a
current window, use any of those:

command: *:CXXCMakeAlternateFileCurrentWindow*
mapping: |cxx-cmake:conf:alternate_file.mappings.current_window|

                                       *cxx-cmake:alternate_file:split_window*
2) Alternate file in a split window

To switch from header to source or vice versa and load alternate file in a
split window, use any of those:

command: *:CXXCMakeAlternateFileSplitWindow*
mapping: |cxx-cmake:conf:alternate_file.mappings.split_window|

                                      *cxx-cmake:alternate_file:vsplit_window*
3) Alternate file in a vsplit window

To switch from header to source or vice versa and load alternate file in a
vsplit window, use any of those:

command: *:CXXCMakeAlternateFileVSplitWindow*
mapping: |cxx-cmake:conf:alternate_file.mappings.vsplit_window|


==============================================================================
CREATE HEADER                                        *cxx-cmake:create_header*

When writing C/C++ code, you will need to create header files. Header file
should have include guard (#ifndef, #define, #endif). You could create foo.hpp
without a problem, but writing include guard on your own every single time is
waste of time and energy. This should be done automatically when you create
header file and this functionality does that.

To create header file you have couple options:

                                              *cxx-cmake:create_header:create*
1) Create header

command: *:CXXCMakeCreateHeader*
mapping: |cxx-cmake:conf:create_header.mappings.create|

                                         *cxx-cmake:create_header:create_edit*
2) Create header and edit in a current window

command: *:CXXCMakeCreateHeaderEdit*
mapping: |cxx-cmake:conf:create_header.mappings.create_edit|

                                   *cxx-cmake:create_header:create_edit_split*
3) Create header and edit in a split window

command: *:CXXCMakeCreateHeaderEditSplit*
mapping: |cxx-cmake:conf:create_header.mappings.create_edit_split|

                                  *cxx-cmake:create_header:create_edit_vsplit*
4) Create header and edit in a vsplit window

command: *:CXXCMakeCreateHeaderEditVSplit*
mapping: |cxx-cmake:conf:create_header.mappings.create_edit_vsplit|


Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the file you want to create without
extension (but if you pass it, it will be removed and what extension will be
used is defined by |cxx-cmake:conf:source.settings.header_extension|). Any
missing directory in the hierarchy will be created.

Note: All of the above commands will emit CXXCMakeHeaderCreatedEvent if the
file was created.


Include guard is a string in the form of:

    PN_D1_D2_D3_F_EXT

where:
    PN          - project name taken from |cxx-cmake:api:get_project_name()|,
                  or |ProsetGetProjectName()| - it is the same,
    D1, D2, D3  - D1/D2/D3 path to the file F,
    F           - filename,
    EXT         - extension of the file F taken from
                  |cxx-cmake:conf:source.settings.header_extension|

example:
    FOO1_SRC_BOO_FOO_BLA_HPP

src/boo/foo/bla.hpp in foo1 project.


Usage example:
    :CXXCMakeCreateHeader src/boo/foo/bla

will create bla.hpp file (if hpp is header extension in configuration) in the
src/boo/foo directory hierarchy (creating directories if needed) whose content
looks like this:

    #ifndef FOO1_SRC_BOO_FOO_BLA_HPP
    #define FOO1_SRC_BOO_FOO_BLA_HPP


    #endif // FOO1_SRC_BOO_FOO_BLA_HPP


==============================================================================
CREATE SOURCE                                        *cxx-cmake:create_source*

Besides header files, you will also create source files. Source file does not
have any include guard, but very often it includes header file using #include
directive. To make life just a little bit more comfortable - even if it is not
a big deal - this #include directive is inserted automatically by following
commands.

To create source file you have couple options:

                                              *cxx-cmake:create_source:create*
1) Create source

command: *:CXXCMakeCreateSource*
mapping: |cxx-cmake:conf:create_source.mappings.create|

                                         *cxx-cmake:create_source:create_edit*
2) Create source and edit in a current window

command: *:CXXCMakeCreateSourceEdit*
mapping: |cxx-cmake:conf:create_source.mappings.create_edit|

                                   *cxx-cmake:create_source:create_edit_split*
3) Create source and edit in a split window

command: *:CXXCMakeCreateSourceEditSplit*
mapping: |cxx-cmake:conf:create_source.mappings.create_edit_split|

                                  *cxx-cmake:create_source:create_edit_vsplit*
4) Create source and edit in a vsplit window

command: *:CXXCMakeCreateSourceEditVSplit*
mapping: |cxx-cmake:conf:create_source.mappings.create_edit_vsplit|


Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the file you want to create without
extension (but if you pass it, it will be removed and what extension will be
used is defined by |cxx-cmake:conf:source.settings.source_extension|). Any
missing directory in the hierarchy will be created.

Note: All of the above commands will emit CXXCMakeSourceCreatedEvent if the
file was created.


Usage example:
    :CXXCMakeCreateSourceEdit src/boo/foo/bla

will create bla.cpp file (if cpp is source extension in configuration) in the
src/boo/foo directory hierarchy (creating directories if needed) whose content
looks like this:

    #include "bla.hpp"

additionally, file will be opened in a current window.

Note: For now, including header file is from the same directory as source
file. Future plan is to add functionality to include it from different
directory, same idea is planned for |cxx-cmake:alternate_file|.


==============================================================================
CREATE HEADER AND SOURCE                      *cxx-cmake:create_header_source*

Create header and source files can be done at one step. Use any of the
following commands to achvieve that.

To create header and source files you have couple options:

                                       *cxx-cmake:create_header_source:create*
1) Create header and source

command: *:CXXCMakeCreateHeaderSource*
mapping: |cxx-cmake:conf:create_header_source.mappings.create|

                            *cxx-cmake:create_header_source:create_edit_split*
2) Create header and source and edit in split windows

command: *:CXXCMakeCreateHeaderSourceEditSplit*
mapping: |cxx-cmake:conf:create_header_source.mappings.create_edit_split|

                    *cxx-cmake:create_header_source:create_edit_current_split*
3) Create header and source and edit in current and split window

command: *:CXXCMakeCreateHeaderSourceEditCurrentSplit*
mapping:
|cxx-cmake:conf:create_header_source.mappings.create_edit_current_split|

                           *cxx-cmake:create_header_source:create_edit_vsplit*
4) Create header and source and edit in vsplit windows

command: *:CXXCMakeCreateHeaderSourceEditVSplit*
mapping: |cxx-cmake:conf:create_header_source.mappings.create_edit_vsplit|

                   *cxx-cmake:create_header_source:create_edit_current_vsplit*
5) Create header and source and edit in current and vsplit window

command: *:CXXCMakeCreateHeaderSourceEditCurrentVSplit*
mapping:
|cxx-cmake:conf:create_header_source.mappings.create_edit_current_vsplit|


Except from Create Header and Create Source, you can not create and edit both
files in the same window, which is pretty much understandable, that is why,
you have option to open them in split or vsplit windows. You can also use
current window for header file and new split or vsplit window for source file.

Each of the commands requires one argument (therefore mapping is a shortcut
for the command), which is path to the files without extension* you want to
create. Any missing directory in the hierarchy will be created.

*) name for both files is the same except from extension. If you pass
extension on the other hand, it will be removed and extensions will be used as
they are defined in:

    - |cxx-cmake:conf:source.settings.header_extension|,
    - |cxx-cmake:conf:source.settings.source_extension|.

Note: All of the above commands will emit CXXCMakeHeaderCreatedEvent if header
file was created and CXXCMakeSourceCreatedEvent if source file was created.


==============================================================================
BUILD                                                        *cxx-cmake:build*

One of the key functionalities of cxx-cmake is to build your project directly
from Vim. Build process is done in the background, which means without loosing
ability to move around in Vim and doing other things.

You have several options at your disposal:

                                                       *cxx-cmake:build:build*
1) Build

Build process is defined by CMakeLists.txt file and it uses CMake to do the
job using |AsyncRun| plugin. Automatically output of build process is loaded
in QuickFix window. If build is success, then QuickFix window is closed
automatically. If warning or error is detected, QuickFix window is left open.

All build files are put into |cxx-cmake:conf:build.settings.build_directory|
directory. Location of build result (application, library) depends on
configuration in CMakeLists.txt (not in configuration file of cxx-cmake!).
For more information see |cxx-cmake:cmake:bin_directory|.

To build project use command or mapping:

command: *:CXXCMakeBuild*
mapping: |cxx-cmake:conf:build.mappings.build|

                                                       *cxx-cmake:build:clean*
2) Clean

You may want just to remove |cxx-cmake:conf:build.settings.build_directory|
directory which stores all previous build files (object files, CMake temporary
files, build result). 

To do so, use command or mapping:

command: *:CXXCMakeClean*
mapping: |cxx-cmake:conf:build.mappings.clean|

If you want to remove build directory, you probably want to build your project
from scratch. You may like to do both at once.

                                             *cxx-cmake:build:clean_and_build*
3) Clean && Build

To get rid of previous build files (object files, CMake temporary files, build
result) and to build your project from scratch you do not have to remove build
directory manually and then build project. You may want to use command or
mapping that is designed for that.

To build your project from scratch use command or mapping:

command: *:CXXCMakeCleanAndBuild*
mapping: |cxx-cmake:conf:build.mappings.clean_and_build|


==============================================================================
RUN                                                            *cxx-cmake:run*

Another very important functionality of cxx-cmake is to run your application
from Vim. You have two options, first one is to run without arguments, and the
other one is to run with them. So, after build is completed, use one of the
following commands or mappings to do what you want.

1) To run your application without arguments, use command or mapping:

command: *:CXXCMakeRun*
mapping: |cxx-cmake:conf:run.mappings.run|

2) To run your application with arguments, use command or mapping:

command: *:CXXCMakeRun* arg1 arg2 ...
mapping: |cxx-cmake:conf:run.mappings.run_args|

Application is run in Vim inside terminal.


==============================================================================
SYMBOLS                                                    *cxx-cmake:symbols*

To easily navigate through the source code of your project and possibly
external source code (for example: libraries) ctags and cscope applications
are used by cxx-cmake. These applications are well known and that is why it
should not be a big problem to make them available in your system. Ctags
generates tags file and cscope generates symbols cross-reference file. Both of
them will be referred as symbols database.

To use Vim tags module you need to generate tags file and update |'tags'|
option to point to it.  To use cscope you need to have Vim compiled with
+cscope module (you can find it in |:version|) and then generate cscope
symbols file and connect it to the cscope module using |:cs| add command.

In cxx-cmake these tedious and boring tasks are done automatically not to
bother you every single time you start Vim or load cxx-cmake Settings Object.

                                            *cxx-cmake:symbols:update_symbols*
When cxx-cmake Settings Object is loaded and we are in the project
(|ProsetIsProject()|, |cxx-cmake:api:is_project()|) |cxx-cmake:api:enable()|
is invoked which does all necessary things to make ctags and cscope symbols be
available in Vim. State of the symbols database is on |cxx-cmake:api:enable()|
time point.  If you add new or modify current source files later, then your
new symbols will most likely not be visible until you regenerate symbols
database (here both ctags and cscope, you can also do it separately). For now,
this has to be done manually using either command or a mapping.

command: *:CXXCMakeUpdateSymbols*
mapping: |cxx-cmake:conf:symbols.mappings.update_symbols|

Future plan is to make it automatically also.


==============================================================================
CTAGS                                                        *cxx-cmake:ctags*

In |cxx-cmake:api:enable()| first step is to set Vim option |'tags'| to have
appropriate values (paths):

    - *cxx-cmake:ctags:ctags_file* - path to the ctags symbols file, set to
      |cxx-cmake:conf:temporary.settings.temporary_directory|/ctags,
    - |cxx-cmake:conf:ctags.settings.external_ctags_files| - list of paths
      to already generated (not by cxx-cmake) ctags symbols files most likely
      for some external sources.

Second step is to generate ctags symbols (tags) file from:

    - |cxx-cmake:conf:source.settings.source_directory| - directory with
      source code of your project,
    - |cxx-cmake:conf:ctags.settings.additional_ctags_directories| - list of
      paths to the directories where some other source code lays.

For both of them, ctags symbols will be generated every time you start Vim,
load cxx-cmake Settings Object, or update them manually.  If you have files
that do not change too often and want to be able to navigate to the symbols
defined there, consider generation of ctags symbols once and add path to
generated file(s) in |cxx-cmake:conf:ctags.settings.external_ctags_files|
(for performance reason).

To update ctags symbols manually, you can use either command or a mapping.

command: *:CXXCMakeUpdateCtagsSymbols*
mapping: |cxx-cmake:conf:ctags.mappings.update_ctags_symbols|

Usage in short: |CTRL-]| jumps to the tag, |CTRL-T|/|CTRL-O| goes back.
See |tags| to get more information about tags.


==============================================================================
CSCOPE                                                      *cxx-cmake:cscope*

In |cxx-cmake:api:enable()| first step is to generate cscope symbols file
from:

    - |cxx-cmake:conf:source.settings.source_directory| - directory with
      source code of your project,
    - |cxx-cmake:conf:cscope.settings.additional_cscope_directories| - list
      of paths to the directories where some other source code lays.

For both of them, cscope symbols will be generated every time you start Vim,
load cxx-cmake Settings Object, or update them manually. If you have files
that do not change too often and want to be able to navigate to the symbols
defined there, consider generation of cscope symbols once and add path to
generated file(s) in |cxx-cmake:conf:cscope.settings.external_cscope_files|
(for performance reason).

Second step is to connect cscope symbols files to Vim cscope module using
|:cs| add command. These files are:

    - *cxx-cmake:cscope:cscope_file* - path to the cscope symbols file, set to
      |cxx-cmake:conf:temporary.settings.temporary_directory|/cscope,
    - |cxx-cmake:conf:cscope.settings.external_cscope_files| - list of paths
      to already generated (not by cxx-cmake) cscope symbols files most likely
      for some external sources.

To update cscope symbols manually, you can use either command or a mapping.

command: *:CXXCMakeUpdateCscopeSymbols*
mapping: |cxx-cmake:conf:cscope.mappings.update_cscope_symbols|

You have two options how to use cscope in Vim with cxx-cmake:

    - use Vim cscope commands,
    - use cxx-cmake mappings (shortcut for above).

Using cscope command you have to provide name you want to search for. For
mapping there is an assumption it uses <cword> (word under the cursor as a
name). All of these mappings work in normal mode.

command: :cs find a name
mapping: |cxx-cmake:conf:cscope.mappings.a_assignments|

command: :cs find c name
mapping: |cxx-cmake:conf:cscope.mappings.c_functions_calling|

command: :cs find d name
mapping: |cxx-cmake:conf:cscope.mappings.d_functions_called_by|

command: :cs find e name
mapping: |cxx-cmake:conf:cscope.mappings.e_egrep|

command: :cs find f name
mapping: |cxx-cmake:conf:cscope.mappings.f_file|

command: :cs find g name
mapping: |cxx-cmake:conf:cscope.mappings.g_definition|

command: :cs find i name
mapping: |cxx-cmake:conf:cscope.mappings.i_including|

command: :cs find s name
mapping: |cxx-cmake:conf:cscope.mappings.s_symbol|

command: :cs find t name
mapping: |cxx-cmake:conf:cscope.mappings.t_string|

See |cscope| to get more information how to use it.


==============================================================================
CONFIGURATION                                                 *cxx-cmake:conf*

There is only one configuration file that is required by cxx-cmake, this is
|g:proset_settings_file| (JSON file). All parameters in it are optional
(except "proset_settings") - when missing, default (hardcoded) value will be
used. Depending on the parameter itself, the functionality can behave in a
default manner (build_directory and jobs_number will have default values, so
you can build your project), or the functionality can be disabled (mappings
are not available if missing). There are parameters that if present but empty
will take default value anyway.

Additionally each parameter that has a command associated with will name that
command.

There is a parameter type designed to store directory path. Value of such
parameter MUST translate (|simplify()|) to the path below project root path,
otherwise it is treated as incorrect and default value will be taken. Value is
trimmed first.  Even though you can use for example '..' as a part of the
value in such parameters, it is rather advised against ('src/../src/xd' ->
'src/xd').

There is an information that the parameter is checked in the description of
it.

Configuration is stored in JSON format, so below there is simplified example
of cxx-cmake configuration file.

{

"proset_settings":                  "cxx-cmake",

"temporary":
{
    "settings":
    {
        "temporary_directory":      ".vim-proset_tmp"
    }
},

"build":
{
    "settings":
    {
        "build_directory":          "build",
        "jobs":                     "8"
    },
    "mappings":
    {
        "build":                    "mk",
        "clean":                    "<Leader>bc",
        "clean_and_build":          "<S-F10>"
    }
}

}

In the following description of configuration parameters, I will not use JSON
format with braces to describe it, instead I will use format with dots. So,
when I refer to proset_settings I will use:

    proset_settings: "cxx-cmake"

since this is top-level parameter, and when I refer to mapping for building
project it will look like this:

    build.mappings.build: "mk"

String values are surrounded by '"' and array values are in '[]'.

The structure of this configuration file is more or less as follows:

"module":
{
    "settings": { ... },
    "mappings": { ... }
}

Some of the modules will have only settings, some of them will have only
mappings and some of them will have both. Unless otherwise noted, every
mapping parameter that is missing makes corresponding functionality not to be
mapped at all.

Key mapping sequence in configuration can be anything that is valid key
sequence in Vim (in nnoremap, etc).


                                                   *cxx-cmake:proset_settings*
                                              *cxx-cmake:conf:proset_settings*
proset_settings

Mandatory parameter used by Proset plugin to determine what Settings Object
to choose.

Required value:
proset_settings: "cxx-cmake"

                                                    *cxx-cmake:conf:temporary*
                       *cxx-cmake:conf:temporary.settings.temporary_directory*
temporary.settings.temporary_directory

Directory where cscope and ctags temporary (generated) symbols files will be
stored.

If missing, empty or incorrect:
temporary.settings.temporary_directory: ".vim-proset_tmp"


                                                        *cxx-cmake:conf:build*
                               *cxx-cmake:conf:build.settings.build_directory*
build.settings.build_directory

Directory for build files (CMake build files, objects *.o, etc).

If missing, empty or incorrect:
build.settings.build_directory: "build"


                                          *cxx-cmake:conf:build.settings.jobs*
build.settings.jobs

Maximum number of jobs used to build your project (building in parallel). If
you want single job to be used to build your project, set value of 1. If this
parameter has empty value then maximum number of jobs will be used.

If missing:
build.settings.jobs: "1"

For maximum number of jobs:
build.settings.jobs: ""


                                         *cxx-cmake:conf:build.mappings.build*
build.mappings.build

Mapping for build the project. See |cxx-cmake:build:build|.

Example:
build.mappings.build: "mk"


                                         *cxx-cmake:conf:build.mappings.clean*
build.mappings.clean

Mapping for clean the project. See |cxx-cmake:build:clean|.

Example:
build.mappings.clean: "mC"


                               *cxx-cmake:conf:build.mappings.clean_and_build*
build.mappings.clean_and_build

Mapping for clean and build the project.
See |cxx-cmake:build:clean_and_build|.

Example:
build.mappings.clean_and_build: "mK"


                                                          *cxx-cmake:conf:run*
                                             *cxx-cmake:conf:run.mappings.run*
run.mappings.run

Mapping for run the project. See |cxx-cmake:run|.

Example:
run.mappings.run: "mr"


                                        *cxx-cmake:conf:run.mappings.run_args*
run.mappings.run_args

Mapping for run the project with arguments. See |cxx-cmake:run|.

Example:
run.mappings.run_args: "mR"


                                                       *cxx-cmake:conf:source*
                             *cxx-cmake:conf:source.settings.source_directory*
source.settings.source_directory

Source directory where all C/C++ files are placed.

If missing, empty or incorrect:
source.settings.source_directory: "src"


                             *cxx-cmake:conf:source.settings.header_extension*
source.settings.header_extension

Extension for header file when creating file using cxx-cmake commands. This is
also used for alternate-file module (switching between header and source
files).

If missing or empty:
source.settings.header_extension: "hpp"


                             *cxx-cmake:conf:source.settings.source_extension*
source.settings.source_extension

Extension for source file when creating file using cxx-cmake commands. This is
also used for alternate-file module (switching between header and source
files).

If missing or empty:
source.settings.source_extension: "cpp"


                *cxx-cmake:conf:source.settings.additional_search_directories*
source.settings.additional_search_directories

This is a list of additional paths to directories which will be appended to
|'path'|. You can specify one or more, in both cases put them in the array.

If missing:
source.settings.additional_search_directories: []

Example:
source.settings.additional_search_directories: [ "../" ]


                  *cxx-cmake:conf:ctags.settings.additional_ctags_directories*
ctags.settings.additional_ctags_directories

To generate tags file using ctags application you have to specify what source
code directory is going to be parsed.  Using cxx-cmake this is done
automatically for |cxx-cmake:conf:source.settings.source_directory| (parsing
project source code). To parse even more source code (possibly some external
code), put these directories (either one or more) in the array.

If missing:
ctags.settings.additional_ctags_directories: []

Example:
ctags.settings.additional_ctags_directories: [ "../xd", "../../goo/lib/" ]


                          *cxx-cmake:conf:ctags.settings.external_ctags_files*
ctags.settings.external_ctags_files

(todo: do the test)
To use external tags file (already generated, very rarely changing, for
example: standard C or C++ library), you are able to put its path here.
Use array to specify one or more files.

If missing:
ctags.settings.external_ctags_files: []

Example:
ctags.settings.external_ctags_files: [ "/tmp/ctags" ]


                          *cxx-cmake:conf:ctags.mappings.update_ctags_symbols*
ctags.mappings.update_ctags_symbols

Mapping for update ctags symbols manually.

Example:
ctags.mappings.update_ctags_symbols: "mut"


                *cxx-cmake:conf:cscope.settings.additional_cscope_directories*
cscope.settings.additional_cscope_directories

In cxx-cmake, cscope application is used to generate cscope symbols file, by
default it uses |cxx-cmake:conf:source.settings.source_directory|. If you want
to parse source code from different directories as well, then this parameter
is for that. You may specify one or more paths to (external) source
directories, in both cases use array.

If missing:
cscope.settings.additional_cscope_directories: []

Example:
cscope.settings.additional_cscope_directories: [ "../xd", "../../goo/" ]


                        *cxx-cmake:conf:cscope.settings.external_cscope_files*
cscope.settings.external_cscope_files

(todo: do the test)
To use external cscope symbols file (already generated, very rarely changing,
for example: standard C or C++ library), you are able to put its path here.
Use array to specify one or more files.

If missing:
cscope.settings.external_cscope_files: []

Example:
cscope.settings.external_cscope_files: [ "/tmp/cscopeX", "/tmp/cscope2" ]


                        *cxx-cmake:conf:cscope.mappings.update_cscope_symbols*
cscope.mappings.update_cscope_symbols

Mapping for update cscope symbols manually.

Example:
cscope.mappings.update_cscope_symbols: "muc"


                                *cxx-cmake:conf:cscope.mappings.a_assignments*
cscope.mappings.a_assignments

Mapping for searching symbol using cscope querytype a(9): "Find places where
this symbol is assigned a value".

Example:
cscope.mappings.a_assignments: "mea"


                          *cxx-cmake:conf:cscope.mappings.c_functions_calling*
cscope.mappings.c_functions_calling

Mapping for searching symbol using cscope querytype c(3): "Find functions
calling this function".

Example:
cscope.mappings.c_functions_calling: "mec"


                        *cxx-cmake:conf:cscope.mappings.d_functions_called_by*
cscope.mappings.d_functions_called_by

Mapping for searching symbol using cscope querytype d(2): "Find functions
called by this function".

Example:
cscope.mappings.d_functions_called_by: "med"


                                      *cxx-cmake:conf:cscope.mappings.e_egrep*
cscope.mappings.e_egrep

Mapping for searching symbol using cscope querytype e(6): "Find this egrep
pattern".

Example:
cscope.mappings.e_egrep: "mee"


                                       *cxx-cmake:conf:cscope.mappings.f_file*
cscope.mappings.f_file

Mapping for searching symbol using cscope querytype f(7): "Find this file".

Example:
cscope.mappings.f_file: "mef"


                                 *cxx-cmake:conf:cscope.mappings.g_definition*
cscope.mappings.g_definition

Mapping for searching symbol using cscope querytype g(1): "Find this
definition".

Example:
cscope.mappings.g_definition: "meg"


                                  *cxx-cmake:conf:cscope.mappings.i_including*
cscope.mappings.i_including

Mapping for searching symbol using cscope querytype i(8): "Find files
#including this file".

Example:
cscope.mappings.i_including: "mei"


                                     *cxx-cmake:conf:cscope.mappings.s_symbol*
cscope.mappings.s_symbol

Mapping for searching symbol using cscope querytype s(0): "Find this C
symbol".

Example:
cscope.mappings.s_symbol: "mes"


                                     *cxx-cmake:conf:cscope.mappings.t_string*
cscope.mappings.t_string

Mapping for searching symbol using cscope querytype t(4): "Find this text
string".

Example:
cscope.mappings.t_string: "met"


                              *cxx-cmake:conf:symbols.mappings.update_symbols*
symbols.mappings.update_symbols

Mapping for update ctags and cscope symbols manually.  Useful when your
sources have been changed (add new files, modify existing files). New symbols
are not visible before updating symbols database.
See |cxx-cmake:symbols:update_symbols|.

Example:
symbols.mappings.update_symbols: "mu"


                                               *cxx-cmake:conf:alternate_file*
                       *cxx-cmake:conf:alternate_file.mappings.current_window*
alternate_file.mappings.current_window

Mapping for switching between header and source files (in current window).
See |cxx-cmake:alternate_file:current_window|.

Example:
alternate_file.mappings.current_window: "ma"


                         *cxx-cmake:conf:alternate_file.mappings.split_window*
alternate_file.mappings.split_window

Mapping for switching between header and source files (in split window).
See |cxx-cmake:alternate_file:split_window|.

Example:
alternate_file.mappings.split_window: "mza"


                        *cxx-cmake:conf:alternate_file.mappings.vsplit_window*
alternate_file.mappings.vsplit_window

Mapping for switching between header and source files (in vsplit window).
See |cxx-cmake:alternate_file:vsplit_window|.

alternate_file.mappings.vsplit_window: "mzA"


                                                *cxx-cmake:conf:create_header*
                                *cxx-cmake:conf:create_header.mappings.create*
create_header.mappings.create

Mapping for creating (only) header file. See |cxx-cmake:create_header:create|.

Example:
create_header.mappings.create: "mhc"


                           *cxx-cmake:conf:create_header.mappings.create_edit*
create_header.mappings.create_edit

Mapping for creating and editing header file in current window.
See |cxx-cmake:create_header:create_edit|.

Example:
create_header.mappings.create_edit: "mhe"


                     *cxx-cmake:conf:create_header.mappings.create_edit_split*
create_header.mappings.create_edit_split

Mapping for creating and editing header file in split window.
See |cxx-cmake:create_header:create_edit_split|.

Example:
create_header.mappings.create_edit_split: "mhi"


                    *cxx-cmake:conf:create_header.mappings.create_edit_vsplit*
create_header.mappings.create_edit_vsplit

Mapping for creating and editing header file in vsplit window.
See |cxx-cmake:create_header:create_edit_vsplit|.

Example:
create_header.mappings.create_edit_vsplit: "mhv"


                                                *cxx-cmake:conf:create_source*
                                *cxx-cmake:conf:create_source.mappings.create*
create_source.mappings.create

Mapping for creating (only) source file. See |cxx-cmake:create_source:create|.

Example:
create_source.mappings.create: "msc"


                           *cxx-cmake:conf:create_source.mappings.create_edit*
create_source.mappings.create_edit

Mapping for creating and editing source file in current window.
See |cxx-cmake:create_source:create_edit|.

Example:
create_source.mappings.create_edit: "mse"


                     *cxx-cmake:conf:create_source.mappings.create_edit_split*
create_source.mappings.create_edit_split

Mapping for creating and editing source file in split window.
See |cxx-cmake:create_source:create_edit_split|.

Example:
create_source.mappings.create_edit_split: "msi"


                    *cxx-cmake:conf:create_source.mappings.create_edit_vsplit*
create_source.mappings.create_edit_vsplit

Mapping for creating and editing source file in vsplit window.
See |cxx-cmake:create_source:create_edit_vsplit|.

Example:
create_source.mappings.create_edit_vsplit: "msv"


                                         *cxx-cmake:conf:create_header_source*
                         *cxx-cmake:conf:create_header_source.mappings.create*
create_header_source.mappings.create

Mapping for creating (only) header and source files.
See |cxx-cmake:create_header_source:create|.

Example:
create_header_source.mappings.create: "mhsc"


              *cxx-cmake:conf:create_header_source.mappings.create_edit_split*
create_header_source.mappings.create_edit_split

Mapping for creating and editing header and source files in split windows
leaving current window untouched.
See |cxx-cmake:create_header_source:create_edit_split|.

Example:
create_header_source.mappings.create_edit_split: "mhsi"


      *cxx-cmake:conf:create_header_source.mappings.create_edit_current_split*
create_header_source.mappings.create_edit_current_split

Mapping for creating and editing header and source files in current and split
window. See |cxx-cmake:create_header_source:create_edit_current_split|.

Example:
create_header_source.mappings.create_edit_current_split: "mhsI"


             *cxx-cmake:conf:create_header_source.mappings.create_edit_vsplit*
create_header_source.mappings.create_edit_vsplit

Mapping for creating and editing header and source files in vsplit windows
leaving current window untouched.
See |cxx-cmake:create_header_source:create_edit_vsplit|.

Example:
create_header_source.mappings.create_edit_vsplit: "mhsv"


     *cxx-cmake:conf:create_header_source.mappings.create_edit_current_vsplit*
create_header_source.mappings.create_edit_current_vsplit

Mapping for creating and editing header and source files in current and vsplit
window. See |cxx-cmake:create_header_source:create_edit_current_vsplit|.

Example:
create_header_source.mappings.create_edit_current_vsplit: "mhsV"


==============================================================================
DERIVATIVES (CXX-CMAKE-AP)                             *cxx-cmake:derivatives*

Imagine a little bit:

So, you look at the cxx-cmake Settings Dictionary and you consider it to be
good, but not exactly for your needs, it is close, yet not completed.

    - Why the author didn't do some integration with my favourite filesystem
      explorer NERDTree?
    - Why there are no mappings or commands for snippets plugin?
    - Why there is no autocompletion engine involved?
    - and so on...

All C++ programmers would benefit from it, wouldn't they?


Answer:

Well, not exactly, your needs are your needs, not mine or other people.
People like to have their own setup and not to be forced to use something they
don't like or want. That is why I tried to make cxx-cmake Settings Dictionary
as much general as possible with a little few dependencies. Except AsyncRun,
all Vim dependencies should rather be easily met. Since cxx-cmake is the name,
CMake became natural dependency for it. Maybe AsyncRun dependency will be
removed in a future and cxx-cmake will take care of asynchronous task on its
own, but for now it stays, sorry if this makes you angry.

But I have good news for you! You can extend cxx-cmake and make your own
cxx-cmake-ap Settings Dictionary (or choose other, better name) that you will
register in the Proset plugin and this is not as hard as you may initially
think. I hope, you have already read |proset:settings_dictionary| because
there are informations how to do it. Yet, I will give you complete example
anyway.

I did not say that there will never be cxx-cmake-bloated (or similar name;
cxx-cmake with all the goodies, dependent on various plugins, etc) supported
by the plugin. I do not claim that this is a bad idea, but for now, there is
only a simple version, a general one. Another direction could be to extend
cxx-cmake and make all other (even current) dependencies (functionalities)
weak (optional).


Example:

Some people like NERDTree filesystem explorer, some people don't, because they
prefer to use fuzzy-finder plugins. If you are in the first group, you may
have noticed that when you use any of CXXCMakeCreate* command, NERDTree window
is not updated and you do not see newly created files immediately. To see them
you have to refresh NERDTree window manually, which of course is a little bit
annoying.

So let's get started to get it done automatically.

    if exists("g:loaded_proset_settings_cxx_cxx_cmake_ap")
        finish
    endif
    let g:loaded_proset_settings_cxx_cxx_cmake_ap = 1
    
    " (1)
    runtime plugin/settings/cxx/cxx_cmake.vim
    
    let s:cxx_cmake_ap = {'properties': {}}
    
    " (2)
    function! s:cxx_cmake_ap.construct(config, settings_name)
        let l:ret = deepcopy(self)
        let l:ret.parent = CXXCMakeConstruct(a:config)
        let l:ret.properties["settings_name"] = a:settings_name
        return l:ret
    endfunction
    
    function! s:cxx_cmake_ap.is_project()
        return self.parent.is_project()
    endfunction
    
    function! s:cxx_cmake_ap.get_project_name()
        return self.parent.get_project_name()
    endfunction
    
    function! s:cxx_cmake_ap.get_properties()
        return self.parent.get_properties()
    endfunction
    
    function! s:cxx_cmake_ap.get_settings_name()
        return self.properties.settings_name
    endfunction
    
    " (3)
    function! s:cxx_cmake_ap.enable()
        call self.parent.enable()
        " (4)
        autocmd User CXXCMakeHeaderCreatedEvent :NERDTreeRefreshRoot
        autocmd User CXXCMakeSourceCreatedEvent :NERDTreeRefreshRoot
    endfunction
    
    function! s:cxx_cmake_ap.disable()
        autocmd! User CXXCMakeHeaderCreatedEvent
        autocmd! User CXXCMakeSourceCreatedEvent
        call self.parent.disable()
    endfunction
    
    " (5)
    autocmd User ProsetRegisterSettingsEvent
        \ call ProsetRegisterSettings("cxx-cmake-ap", "CXXCMakeApConstruct")
    
    " (6)
    function! CXXCMakeApConstruct(config)
        return s:cxx_cmake_ap.construct(a:config, "cxx-cmake-ap")
    endfunction

Why does it look this way is explained in |proset:settings_dictionary| in more
details, but I have marked some places which now need to be explained:

    (1) - we are going to use CXXCMakeConstruct(), we have to have its
          definition already sourced,
    (2) - definition of a construct() "member function" which uses public
          cxx-cmake function to create an object (parent),
    (3) - here is a code that does the job of refreshing NERDTree window.
          cxx-cmake Settings Object produces events when file was created:

              - CXXCMakeHeaderCreatedEvent - when header was created,
              - CXXCMakeSourceCreatedEvent - when source was created.

          So, we are connecting this event to the action of refreshing
          NERDTree.  Remember to revert all the side efects of enable() in
          disable() function,
    (4) - you can easily put those commands in your vimrc, but then you will
          probably have these connections always, not only when needed (the
          idea of Proset plugin),
    (5) - register settings name and assign public constructor function to it,
    (6) - constructor function that has to take one parameter - configuration.

Note:
In (5) and (6) settings name string is "cxx-cmake-ap" and it has to be
identical in both places! Internal constructor (2) takes string as a second
argument which is settings name. This means that you can create multiple
Settings Objects from cxx-cmake-ap Settings Dictionary, just duplicate (5)
and (6) and fill them with appropriate settings name string.

Rest is up to you what you want to have in your cxx-cmake-ap Settings
Dictionary.  This is just an idea of what you can do. Feel free to experiment
with it. Enjoy.


==============================================================================
CMAKE                                                        *cxx-cmake:cmake*

                                                *cxx-cmake:cmake:introduction*
To build C or C++ code, you can enter compiler command directly on the command
line, like this:

    g++ -std=c++11 main.cpp -o main

which is ok if you have one or maybe couple files.

Another option is to use make command which expects to have Makefile file as
its input. So, you can write such Makefile which gathers all rules and
properties of the build process, it is basically typical solution in Linux
environment, but writing Makefile is not so easy.

Another - but not last of course - solution is to use CMake build system
generator which has its own input file CMakeLists.txt with its own language to
define rules and properties of the build process. Based on this input file it
can generate multiple different build system files - for example Makefile -
using available generators (see CMake generators for more information).
CMakeLists.txt has definition how to build project, but this is CMake job to
generate appropriate build system files on supported Operating System to make
your program compile.

                                                    *cxx-cmake:cmake:settings*
All following settings are not taken from configuration file, they are
calculated internally by cmake.vim module file.

                                         *cxx-cmake:cmake:settings:input_file*
                                                  *cxx-cmake:cmake:input_file*
The input file for CMake is CMakeLists.txt, which is placed in the project
root.

                                       *cxx-cmake:cmake:settings:project_name*
                                                *cxx-cmake:cmake:project_name*
Although I tried not to force users to provide lot of dependencies (there are
very few, see |cxx-cmake:dependencies|), neither force them to change their
setup, but there is one thing that has to be done in CMakeLists.txt to make
cxx-cmake work. CMakeLists.txt has to define PROJECT_NAME variable, i.e.:

    set(PROJECT_NAME "foo192")

in which project name has to be in double quote. This name is used as build
result name (application, library).

                                      *cxx-cmake:cmake:settings:bin_directory*
                                               *cxx-cmake:cmake:bin_directory*
Another thing, but optional, is the definition of one of the following CMake
variables:

    - CMAKE_RUNTIME_OUTPUT_DIRECTORY - for application,
    - CMAKE_ARCHIVE_OUTPUT_DIRECTORY - for static library,
    - CMAKE_LIBRARY_OUTPUT_DIRECTORY - for shared library.

It means that you can specify output (bin) directory for your project
application or library. If you do not specify the path, then result of your
build will be placed in |cxx-cmake:conf:build.settings.build_directory|. You
can change your output directory using these variables like this:

1) Application is in project_root/bin/

    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PROJECT_SOURCE_DIR}/bin")

2) Static library is in |cxx-cmake:conf:build.settings.build_directory|/bin/

    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "bin")

                                         *cxx-cmake:cmake:settings:is_project*
If |ProsetIsProject()| returns TRUE then cxx-cmake can be used (we are in the
project), otherwise it can not be used (we are not in the project). To make it
return TRUE, all of the following conditions have to be TRUE:

    - CMakeLists.txt is in the project root (current directory) and can be
      read,
    - |cxx-cmake:conf:source.settings.source_directory| exists,
    - |g:proset_settings_file| can be read,
    - PROJECT_NAME variable is defined in CMakeLists.txt and is not empty.

==============================================================================

           ████████╗██╗  ██╗███████╗    ███████╗███╗   ██╗██████╗
           ╚══██╔══╝██║  ██║██╔════╝    ██╔════╝████╗  ██║██╔══██╗
              ██║   ███████║█████╗      █████╗  ██╔██╗ ██║██║  ██║
              ██║   ██╔══██║██╔══╝      ██╔══╝  ██║╚██╗██║██║  ██║
              ██║   ██║  ██║███████╗    ███████╗██║ ╚████║██████╔╝
              ╚═╝   ╚═╝  ╚═╝╚══════╝    ╚══════╝╚═╝  ╚═══╝╚═════╝

==============================================================================

 vim:tw=78:et:ft=help:norl:
