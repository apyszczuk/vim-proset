*proset*
*proset.txt*  Project Settings Loader

              ██████╗ ██████╗  ██████╗ ███████╗███████╗████████╗
              ██╔══██╗██╔══██╗██╔═══██╗██╔════╝██╔════╝╚══██╔══╝
              ██████╔╝██████╔╝██║   ██║███████╗█████╗     ██║
              ██╔═══╝ ██╔══██╗██║   ██║╚════██║██╔══╝     ██║
              ██║     ██║  ██║╚██████╔╝███████║███████╗   ██║
              ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝   ╚═╝

Author:     Artur Pyszczuk <apyszczuk@gmail.com>
License:    Same terms as Vim itself (see |license|)
Website:    https://github.com/apyszczuk/vim-proset

==============================================================================
TABLE OF CONTENTS

 1) INTRODUCTION                                         |proset:introduction|
 2) SETTINGS                                                 |proset:settings|
 3) PLUGIN VARIABLES                                        |proset:variables|
 4) CONFIGURATION                                       |proset:configuration|
 5) EVENTS                                                     |proset:events|
 6) SETTINGS API                                         |proset:settings_api|
 7) SETTINGS DICTIONARY                           |proset:settings_dictionary|
 8) API                                                           |proset:api|
 9) COMMANDS                                                 |proset:commands|
10) SUPPORTED SETTINGS DICTIONARIES   |proset:supported_settings_dictionaries|
11) CONTRIBUTE                                             |proset:contribute|


==============================================================================
INTRODUCTION                                             *proset:introduction*

Anytime you want to have different settings for different projects using Vim,
you probably have a problem. You can edit your vimrc before opening a project,
write some file type plugins, create file type autocommands, or use local
setup (see |'exrc'|). File type plugins and autocommands are completely ok,
but they react to specific file types (that might not be related to any
project). Project can have multiple files with different types and setting
options depending on file type is of course possible, but hard to be
switchable if different project wants to have those options configured
differently for the same file types. Local setup is possible, but advised
against. Changing vimrc from project to project is rather last solution you
would take. Proset plugin aims to solve this problem.

The idea of Proset plugin is to have a configuration file that is stored
within the project (just like IDEs do) having parameter that informs plugin
what project settings should be loaded. By project settings I mean everything
that is needed for you when you develop your project, it can be, but not
restricted to:

    - configuration of Vim itself,
    - mappings for builing project,
    - mappings for running project,
    - mappings in general,
    - configuration of plugins,
    - creating symbols database to easily navigate through the source code,
    - easily switch between related files,
    - ...and much more.

Basically everything you would normally put in your vimrc but local to the
project.

You can start Vim in your project root path and project settings will be
loaded automatically (if all the conditions are met of course). You can also
start Vim in different location and load project settings later using Proset
function or command.


==============================================================================
SETTINGS                                                     *proset:settings*

Proset Settings is something that stores all your project specific
configuration. It is implemented as a dictionary with specific interface (see
|Dictionary-function|, |numbered-function|). Object of such dictionary can be
registered in the plugin, either by plugin itself, or by you if your Settings
Dictionary is not supported by the plugin.

Settings Dictionary and Settings Object are basically what is in object
oriented languages known as class and instance of that class (object) and
therefore from now on I will refer rather to Settings Object than to Settings
Dictionary because object can be registered in the plugin and type can not.
Additionally, what is worth to notice is the fact that from one Settings
Dictionary (type) you can create multiple objects which can be registered as
long as they have different names.

Each Settings Object has to have a name (unique among other registered
Settings Objects) and it is not about object name in the code, but the string
coming from its function. This name is used to register Settings Object in
the plugin or when decision has to be made which Settings Object to choose
based on the string from configuration file.

Supported Settings Dictionaries can be found under plugin/settings/ directory.
Each Settings Dictionary definition (except Default) is placed there in an
appropriate directory with meaningful name roughly speaking what is it for.

For example:
plugin/settings/cxx/cxx-cmake.vim

See also |proset:supported_settings_dictionaries|.

                                                     *proset:settings:default*

There is a special Settings Dictionary called Default (defined in
autoload/proset/settings/default.vim file) that has two reasons to exist:

    - default settings (no settings at all) - in case when plugin is enabled,
      but no configuration file is found, so probably most of the time you
      start Vim,
    - interface definition - all Settings Dictionaries have to have the same
      public interface as Default one has.


One more thing:

You will use Proset plugin by its public functions or commands, however some
of those functions does not have any logic, they use Settings Object (which
has the logic) to do the task and possibly return value. In object oriented
world this is known as composition. Settings Object that Proset plugin is
currently operating on is referred as current in the following documentation.


==============================================================================
PLUGIN VARIABLES                                            *proset:variables*

                                                      *g:proset_settings_file*
g:proset_settings_file

This variable stores path to project settings file. It has to be a relative
subpath to current working directory. Error *proset-E1* may occur if value
results in:

    - empty value,
    - current directory ("."),
    - global path ("/tmp/settings", even if it leads you below your current
      working directory),
    - path above current working directory ("..").

Default value is ".vim-proset/settings.json".

To change default value, put this in your vimrc:

 let g:proset_settings_file = ".ide/cfg"

Variable can not be altered on the fly.


==============================================================================
CONFIGURATION                                           *proset:configuration*

The only one configuration file that is read and required by the plugin is
|g:proset_settings_file|. This is a JSON file. To get more familiar with the
format, please refer to RFC7159 document. Check out |json_decode()| to see how
Vim parses JSON string. 

So, the simplest configuration file looks like this:

                                                   *proset:configuration:file*
{
    "proset_settings": "cxx-cmake"
}

This is the only one required configuration parameter. All other parameters
that are there are Settings Object specific, but the configuration file does
not have to have more parameters, you can read them on your own using your own
parser, you can even read them from multiple configuration files, etc, it is
up to you if you choose Vim JSON parser or not.

Comments and duplicate keys are not accepted by the parser.

                                                  *proset:configuration:get()*
Lets say config is a dictionary object created by |json_decode()|. To get
value from it, you can normally do it just like for any other dictionary,
meaning:

 let l:x_val = config["foo"]["boo"]

or even simpler

 let l:x_val = config.foo.boo

that is fine, you can do it, but if there is no such key in config dictionary,
you will get an error. So, you have to check if config |has_key()| returns
TRUE always before accesing it, or you may want to use a helper function that
returns default value when such key is not defined. This function is defined
in autoload/proset/lib/dict.vim and its signature looks like this:

 proset#lib#dict#get(dictionary, default_value, ...)

where:
    a:dictionary    - is a dictionary, here created by JSON parser,
    a:default_value - is a value which will be returned if dictionary does not
                      have key you specify in '...',
    ...             - variadic string arguments that is a "path" to the key.

So, to use get() function, you should do:

 let l:x_val = proset#lib#dict#get(config, 10, "foo", "boo")

and if key 'foo.boo' was in the configuration file then l:x_val has its value,
otherwise it has value of 10, which is the default value passed as second
argument to get() function.

Use |ProsetGetConfiguration()| function to get configuration dictionary.


==============================================================================
EVENTS                                                         *proset:events*

Proset plugin offers autocommand events to register Settings Objects and to
inform you that Settings Object was chosen.

                                                 *ProsetRegisterSettingsEvent*
ProsetRegisterSettingsEvent

If you want to register Settings Object, then you have to use this event, and
do this in an autocommand, like this:

 autocmd User ProsetRegisterSettingsEvent
         \ call ProsetRegisterSettings("cxx-cmake", "CXXCMakeCtor")

This event is fired before choosing Settings Object. Real example is presented
later in the documentation (|proset:settings_dictionary|).

                                         *ProsetRegisterInternalSettingsEvent*
ProsetRegisterInternalSettingsEvent

This event is used to register plugin supported Settings Objects. It is
exactly like |ProsetRegisterSettingsEvent|, except it is invoked before it.
This should not be used to register Settings Objects outside of the Proset
plugin.

                                                   *ProsetSettingsChosenEvent*
ProsetSettingsChosenEvent

Actions attached to this autocommand event are executed whenever Settings
Object is loaded, either automatically on Vim start, or manually using Proset
commands. In both cases current Settings Object is changed if possible. Before
VimEnter and ProsetSettingsChosenEvent, current Settings Object is initialized
to Default Settings Object. So, if you want to use public API before VimEnter
and you expect Proset to have actual Settings Object initialized, register
your action on this event, this way:

 function! Foo()
     let l:p = ProsetGetProperties()
 endfunction

 autocmd User ProsetSettingsChosenEvent call Foo()

For the manual loading case, current Settings Object is the one you loaded
before, or it can be Default Settings Object as well, if no Settings Object
was loaded.


==============================================================================
SETTINGS API                                             *proset:settings_api*

Note:
When documentation says that something returns FALSE it means that it returns
0 and if something returns TRUE then it returns other |Number| than 0, most
likely 1.

To create new Settings Dictionary you need to follow interface that is defined
in |proset:settings:default| Settings Dictionary, and it is presented below.

Keep in mind that you will not use actual Settings Object directly. You will
use it via Proset public functions (|proset:api|).

                                            *proset:settings_api:is_project()*
s:settings.is_project()

Returns TRUE if it is a project and FALSE otherwise. Each Settings Object can
have different requirements, but lets say that if project directory (root
path) has src directory it is a project (TRUE) and if it does not have, it is
not a project (FALSE). Settings Object can return TRUE unconditionally as
well.

Important thing to know is that enable() and disable() are called only if
is_project() returns TRUE.

FALSE on Default Settings Object.

                                      *proset:settings_api:get_project_name()*
s:settings.get_project_name()

Returns project name as string. The value is probably taken from somewhere
else (after some parsing, that is my guess), rather than returned as string
literal from this function.

Empty string on Default Settings Object.

                                        *proset:settings_api:get_properties()*
s:settings.get_properties()

Returns properties of Settings Object as dictionary. Strongly depends on
actual Settings Object, so rather refer to it. Can not tell here what is
inside. |ProsetGetProperties()| does deep copy of it.

Empty dictionary on Default Settings Object.

                                     *proset:settings_api:get_settings_name()*
s:settings.get_settings_name()

Returns settings name as string. This value (not the function!) is used to
register Settings Object in the plugin (find if such name already exists) and
to choose Settings Object to be loaded. This name has to be unique among other
Settings Objects. Additionaly it is helpful to find out which Settings Object
is currently loaded.

Empty string on Default Settings Object.

                                                *proset:settings_api:enable()*
s:settings.enable()

This function is where all settings are defined. In this function you do all
your mappings, settings, other plugins configuration, basically whatever you
want to do what is different from project to project (common settings probably
are placed in vimrc). You can even create some temporary directories, and
remove them later.

This function is called when Vim fires VimEnter event or user loads project
settings manually (|ProsetLoadSettings|) and when is_project() is TRUE.

This function does nothing on Default Settings Object.

                                               *proset:settings_api:disable()*
s:settings.disable()

This function is like a cleanup function. If you did something in enable(),
you should revert it to the original state. This is the right place to do it.

This function is called when Vim fires VimLeave event or user loads project
settings manually (|ProsetLoadSettings|) or user closes project settings
manually (|ProsetCloseSettings|) and when is_project() is TRUE.

This function does nothing on Default Settings Object.

                                             *proset:settings_api:construct()*
s:settings.construct(config)

You are not forced to have this one, you may want to have different name,
different parameters, however some function that is used to create Settings
Object is required anyway.


Summary:
As you see, Default Settings Dictionary defines |numbered-function|s what is
in other languages known as methods or member functions.  For creating other
Settings Dictionaries you need to follow this scheme. To see how to register
Settings Object in the plugin, see |proset:settings_dictionary|.

                                              *proset:settings_api:exceptions*
Exceptions

Settings Object can throw an exception only from its constructor function
(|proset:settings_dictionary:constructor|) and to make Proset plugin handle
it, it has to be of known "type". Of course it is not a type you may be
familiar with from object oriented programming languages, but it imitates it
in some sense. So, you need to throw a string in the form of:

 proset:construct-settings:x:y

where:
    proset:construct-settings   - always the same string (lowercase),
    x                           - Settings Object name,
    y                           - reason (message) of exception.

 function! CXXCMakeConstructor(config)
     throw "proset:construct-settings:cxx-cmake:some error message"
 endfunction

Note:
Technically exception can be thrown from any place of Settings Dictionary,
however, it will work correctly only if exception is thrown from the
constructor function - meaning the function that is registered in the plugin.


==============================================================================
SETTINGS DICTIONARY                               *proset:settings_dictionary*

Here, example (with explanation) of how to create Settings Dictionary is
provided. 

Keep in mind that implementation you will see here is just an example, you can
store data in different form, as you like, as long as you implement the
interface.

There is no special difference between Settings Dictionary supported by the
plugin and the one written by you, except a place where it is stored and event
used to register it. Plugin supported Settings Dictionaries are placed under
plugin/settings directory and they use ProsetRegisterInternalSettingsEvent to
register itself. Yours rather should be stored in a separate plugin |package|
(vim-proset-ext, or the like) and have to use ProsetRegisterSettingsEvent.

                                      *proset:settings_dictionary:constructor*
Legacy Vim script (in which this plugin is written in) is not an object
oriented programming language, but it imitates it in some sense. Because of
that there is no constructor but we can use a function that creates an object
for us. Normally it would be called a factory function, but from now on when
you see a name constructor, I will refer to that function.

You can construct your Settings Object in several different ways I suppose,
however, a function that is called constructor has to take one parameter,
which is configuration dictionary (|proset:configuration|). You can have
multiple such functions, but you need to register each of them (more on this
later).

                                          *proset:settings_dictionary:package*
Create own plugin package

To create Vim package you have to create appropriate directory tree and then
create Vim script file there.

 $ mkdir -p ~/.vim/pack/vim-proset-ext/start/vim-proset-ext/plugin
 $ touch ~/.vim/pack/vim-proset-ext/start/vim-proset-ext/plugin/xd.vim

                                       *proset:settings_dictionary:definition*
Create Settings Dictionary definition

Note:
When you see self.properties["some_key"] then you should know that the key was
somehow initialized during construction of the Settings Object. 

Put the following code in xd.vim file. 


 if exists ("g:loaded_proset_ext_xd")
     finish
 endif
 let g:loaded_proset_ext_xd = 1

This is a common practice not to include Vim script file more than once.


 let s:obj = {"properties": {}}

This is the definition of the Settings Object that stores functions and data,
yet not initialized. It has key properties, but the name can be changed (if
so, you just need to update usages). Name obj can also be changed to the one
you like more, since it is script-local it does not really matter which one
you choose. The key properties contains all properties of the Settings Object.


 function! s:obj.is_project()
     return self.properties["is_project"]
 endfunction

This function informs plugin whether we are in a project or not. Condition of
that is basically up to you. You need to remember that enable() and disable()
will be invoked only if return value from this function is TRUE.


 function! s:obj.get_project_name()
     return self.properties["project_name"]
 endfunction

This function returns project name (string). How do you do it, it is up to
you. You can take value from configuration file, parse it from other file, you
can even return a string literal, but this should rather be avoided (since
project name would always be the same for all projects).


 function! s:obj.get_properties()
     return self.properties
 endfunction

This function returns properties (dictionary), all the properties you want, it
can be everything from configuration file, or more, or less, depends on you.


 function! s:obj.get_settings_name()
     return "xd"
 endfunction

This function returns Settings Object name (string), which can be helpful to
see what Settings Object is currently loaded.


 function! s:obj.enable()
     call mkdir("tmpdir")
     nnoremap m0 :echo "Hello World"<CR>
 endfunction

Here you do everything you want, all your settings need to be here either
directly on indirectly using other functions. If you have any side effects
that need to be reverted, do it in disable().


 function! s:obj.disable()
     call delete ("tmpdir", "rf")
     nunmap m0
 endfunction

Here you do cleanup of all the side effects of enable().

                           *proset:settings_dictionary:constructor_one_object*
Just before we start with the code, here is the sample settings.json file that
is used as an example for both cases:

{
    "proset_settings": "xd",
    "project_name":    "pro-xd",
    "is_project":      "1",
}


Settings Dictionary Constructor - one object only

 function! s:obj.construct(config)
     let l:ret = deepcopy(self)
 
     let l:ret.properties["project_name"] =
         \ proset#lib#dict#get(a:config, "", "project_name")
     let l:ret.properties["is_project"]   =
         \ proset#lib#dict#get(a:config, "0", "is_project")
 
     return l:ret
 endfunction

This is the internal implementation of Settings Dictionary constructor used
to create Settings Object.  The object a:config is a configuration dictionary
that stores data coming from JSON configuration file. Helper function get()
was used to handle case of missing entry in the file.


 function! XdConstruct(config)
     return s:obj.construct(a:config)
 endfunction

This is the public constructor that is used to create Settings Object by the
plugin when needed. It uses internal constructor implementation because all
the logic of object creation is there, not here. This is just simple wrapper
function that is used to be registered. This function has to take exactly one
parameter which is a configuration object.

 
 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd", "XdConstruct")

If you wonder why this is done in an autocommand, rather than just simple call
to ProsetRegisterSettings() the reason is that if you do this without an
autocommand and this code is sourced before Proset plugin then you get an
error that Proset* functions are not known (plugin has not been sourced yet).

So you need to inform Vim that you want to do this action but on user
autocommand that is invoked from the Proset plugin. 

|ProsetRegisterSettings()| takes settings name (string) and public constructor
function name (string) as arguments. 

Having s:obj.get_settings_name() returning always the same value, we have only
one object of that Settings Dictionary that can be registered (in fact, value
from that function is not the one used to register Settings Object, but it HAS
TO BE THE SAME as first argument passed to ProsetRegisterSettings() which is
the value).

                     *proset:settings_dictionary:constructor_multiple_objects*
Settings Dictionary Constructor - multiple objects

 function! s:obj.get_settings_name()
     return self.properties["settings_name"]
 endfunction

This is different from previous implementation because it uses value that is
stored in a dictionary, which is initialized in the following constructor
implementation.


 function! s:obj.construct(config, settings_name)
     let l:ret = deepcopy(self)
 
     let l:ret.properties["project_name"] =
         \ proset#lib#dict#get(a:config, "", "project_name")
     let l:ret.properties["is_project"]   =
         \ proset#lib#dict#get(a:config, "0", "is_project")
     let l:ret.properties["settings_name"]= a:settings_name
 
     return l:ret
 endfunction
 
 function! XdConstruct1(config)
     return s:obj.construct(a:config, "xd1")
 endfunction
 
 function! XdConstruct2(config)
     return s:obj.construct(a:config, "xd2")
 endfunction
 
 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd1", "XdConstruct1")
 
 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd2", "XdConstruct2")

So, this is one of the possible ways how you can create multiple Settings
Objects from one Settings Dictionary. Just remember to register Settings
Object with the EXACT SAME name as s:obj.get_settings_name() returns.
You may want to use some helper function that returns actual name and call it
in both places.


==============================================================================
API                                                               *proset:api*

To interact with Proset plugin (besides plugin variables) you have to use
public API described below or commands defined later.

                                                    *ProsetRegisterSettings()*
ProsetRegisterSettings(settings_name, constructor_name)

This function is used to associate a:constructor_name with a:settings_name in
the internal storage. If a:settings_name key is already defined in internal
storage dictionary, then you will get *proset-E10* error and Proset plugin
will not work.  There is an assumption that registered Settings Objects names
are unique.

If user wants to register its own Settings Object then it should be called
from an autocommand, rather than just a function call from own plugin package.
Why? Own plugin package can be sourced before this plugin, so the function is
unknown there.  Using packadd to enable this plugin at the beginning of vimrc
is possible, but forcing user to do so is rather unacceptable.

Example:
 autocmd User ProsetRegisterSettingsEvent
         \ call ProsetRegisterSettings("cxx-cmake", "CXXCMakeConstruct")

Take a look at |proset:settings_dictionary| to see how to create Settings
Dictionary.

Note:
Important thing to know is the fact that Settings Object is created only when
needed. When Vim tries to load project settings and the conditions are met, it
takes proset_settings value from configuration file and checks if such name
was already registered. If so, it takes constructor function name that was
registered and use it to create Settings Object passing configuration
dictionary as argument.

                                                           *ProsetIsProject()*
ProsetIsProject()

This function is used to get information whether we are in the project.  Each
Settings Object defines its own rules for that. Returns TRUE if it is a
project, FALSE otherwise.

                                                     *ProsetGetSettingsName()*
ProsetGetSettingsName()

This function is used to get current Settings Object name. 

                                                      *ProsetGetProjectName()*
ProsetGetProjectName()

This function is used to get project name. Each Settings Object prepares
string with a name based on its own rules.

                                                       *ProsetGetProperties()*
ProsetGetProperties()

This function is used to get project properties in the form of a dictionary.
Each Settings Object prepares it in its own way. It creates deep copy of
returned value from Settings Object function.

                                                    *ProsetGetConfiguration()*
ProsetGetConfiguration()

This function is used to get configuration data (|proset:configuration:file|)
in the form of a dictionary - everything that was read from configuration
file. It creates deep copy of internal storage.

                                                        *ProsetLoadSettings()*
ProsetLoadSettings(path)

This function loads project settings from provided path. Even though loading
project settings function is called when Vim starts, it can also be called to
change projects settings (load different project, from different path).

First of all, checking if configuration file (|proset:configuration|) exists.
If missing, *proset-E20* is presented to you.

Then configuration file is parsed, if proset_settings parameter is empty or
missing you will get *proset-E21* error.

If syntax error (JSON format) occurs during parsing configuration file, then
*proset-E22* is what you get.

If configuration file has duplicate keys, then *proset-E23* occurs.

Configuration file can be correct, however if proset_settings holds value that
has not been registered (not supported Settings Object), then *proset-E30*
shows up.

There is also possibility that constructor of Settings Object throws an
exception due to some circumstances, then *proset-E40* is what you see.

If any error occurs during loading procedure, nothing happens with currently
loaded Settings Object.

If none of the above errors happen, then:
    - create chosen Settings Object and treat it as current,
    - call disable() on previous Settings Object,
    - change current directory to path,
    - call enable() on current Settings Object,
    - execute actions registered on |ProsetSettingsChosenEvent| autocommand.

On success 0 is returned, on failure error code is returned.

Note:
You CAN NOT change current directory (|:cd|) and if you do so, then your
project settings will be closed using |ProsetCloseSettings()|. There are
reasons why, couple of them are:

    - beeing in a project means beeing in the root path of the project,
    - if enable() creates directory, the directory should be deleted in
      disable() - so if current directory changes between enable() and
      disable() what directory will be deleted?
    - it would be very inconvenient for Settings Objects commands like delete
      build files, create files, etc to be outside of the project root path.


                                                      *ProsetReloadSettings()*
ProsetReloadSettings()

This is the same as ProsetLoadSettings(".").

                                                       *ProsetCloseSettings()*
ProsetCloseSettings()

If you do not want your Vim to be in a project anymore, you can close Vim and
start over or you can use close functionality.

It will:

    - call disable() on current Settings Object,
    - set Default Settings Object as current one,
    - reset internal configuration dictionary causing
      |ProsetGetConfiguration()| to return an empty value.

This function does not return value.


==============================================================================
COMMANDS                                                     *proset:commands*

Although you can use public API to do the same things, it is much more
convenient to use Vim commands for some of them.

*:ProsetLoadSettings* path - calls |ProsetLoadSettings| (passing path to it),
*:ProsetReloadSettings*    - calls |ProsetReloadSettings| (no arguments),
*:ProsetCloseSettings*     - calls |ProsetCloseSettings| (no arguments).

==============================================================================
SUPPORTED SETTINGS DICTIONARIES       *proset:supported_settings_dictionaries*

List of supported Settings Dictionaries:

    - |cxx-cmake| - for C/C++ development using CMake as a build system,


==============================================================================
CONTRIBUTE                                                 *proset:contribute*

If you see a bug, or something that can be improved, or have an idea of a new
Settings Dictionary or even better you have already written one and want it to
be supported by Proset plugin directly, just let me know via GitHub or email.


==============================================================================

           ████████╗██╗  ██╗███████╗    ███████╗███╗   ██╗██████╗
           ╚══██╔══╝██║  ██║██╔════╝    ██╔════╝████╗  ██║██╔══██╗
              ██║   ███████║█████╗      █████╗  ██╔██╗ ██║██║  ██║
              ██║   ██╔══██║██╔══╝      ██╔══╝  ██║╚██╗██║██║  ██║
              ██║   ██║  ██║███████╗    ███████╗██║ ╚████║██████╔╝
              ╚═╝   ╚═╝  ╚═╝╚══════╝    ╚══════╝╚═╝  ╚═══╝╚═════╝

==============================================================================

 vim:tw=78:et:ft=help:norl:
