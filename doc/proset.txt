*proset.txt*   Project Settings Loader And Creator                    *proset*

              ██████╗ ██████╗  ██████╗ ███████╗███████╗████████╗
              ██╔══██╗██╔══██╗██╔═══██╗██╔════╝██╔════╝╚══██╔══╝
              ██████╔╝██████╔╝██║   ██║███████╗█████╗     ██║
              ██╔═══╝ ██╔══██╗██║   ██║╚════██║██╔══╝     ██║
              ██║     ██║  ██║╚██████╔╝███████║███████╗   ██║
              ╚═╝     ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝   ╚═╝

Author:     Artur Pyszczuk <apyszczuk@gmail.com>
License:    Same terms as Vim itself (see |license|)
Website:    https://github.com/apyszczuk/vim-proset

==============================================================================
TABLE OF CONTENTS
==============================================================================

INTRODUCTION                                             |proset:introduction|
SETTINGS                                                     |proset:settings|
PLUGIN VARIABLES                                            |proset:variables|
CONFIGURATION                                           |proset:configuration|
EVENTS                                                         |proset:events|
SETTINGS API                                             |proset:settings_api|
API                                                               |proset:api|
COMMANDS                                                     |proset:commands|
SETTINGS DICTIONARY                               |proset:settings_dictionary|
SUPPORTED SETTINGS DICTIONARIES       |proset:supported_settings_dictionaries|
CONTRIBUTE                                                 |proset:contribute|

==============================================================================
INTRODUCTION                                             *proset:introduction*
==============================================================================

It seems to me that everytime you want to develop some projects using Vim you
encountered some problems with how to set up specific settings for those
projects. I assume that you have (as I do) your favourite mapping for building
your project (compiling code), but commands used for doing so are completely
different for different projects, maybe because those projects are written in
different languages or they use different build systems. Switching between
those commands just to make your mapping work as you want is probably not that
hard, but I guess it is annoying and projects usually have more settings that
a single mapping.

So, you may try to use file type plugin or create file type autocommand. Both
solutions are completely fine and probably are widely used, yet they react to
specific file types which may not be related to any project. On the other hand
project can use multiple different file types which may lead you to situation
where you can build your project from one window but not from the other one
which is also weird.

Another solution is to use local setup (|'exrc'|) but it is advised against by
Vim documentation.

Another try would be to write Vim package and enable and disable it if needed
(either before starting Vim or after). Package would give you all you need for
this project. Another project would have to have its own configuration package
(even it differs a little bit in some values).  It may sounds good for your,
yet configuration of your project would be stored in your Vim configuration
files which is a little bit odd. There would be a lot of duplicated code and
it would be hard to be shareable (configurable).

Changing vimrc from project to project is rather last solution you would take.

Projects of different types (written in different languages) may vary a lot in
terms of settings, but having two projects written in the same language which
vary a little bit in the settings like: file extensions (for instance: cpp vs
cxx) or how to switch to alternate file (for instance: hpp<->cpp or hxx<->cxx)
is begging for something that can handle that easily.

If you feel the pain of above, Proset plugin aims to solve this problem and I
encourage you to familiarize yourself with it.

The idea of Proset plugin is to have a configuration file that:

    - is stored within the project sources (just like IDEs do),
    - is an easy front-end configurator for your project,
    - has parameter that informs plugin what Proset Settings should be loaded.

Proset Settings are described in details in the following section, but in
short it can be treated as specific project type settings (configuration for
that kind of project). For instance, C++ project will naturally have different
kind of settings than Vim plugin project.  It implies that C++ project has to
have different Proset Settings than Vim plugin project.

So for example Proset Settings can include:

    - configuration of Vim itself,
    - mapping for builing project; setting for build (output) directory name,
    - mapping for running project; setting for output window position,
    - creating symbols database to easily navigate through the source code;
      mapping for regenerate symbols; setting for generator bin path,
    - easily switch between related files; mapping for opening the file in
      current or split window,
    - configuration of plugins,
    - ...and much more.

Basically everything you would normally put in your vimrc but local to the
project.

One more thing, Proset Settings describes what can be configured for specific
kind of project. Which Proset Settings has to be loaded and what values are
used to initialize those settings come from Proset configuration file.

In other words:

    Proset Settings + Proset Configuration File = Project Configuration


You can start Vim in your project root path and depending on your Project
Configuration your project will be automatically loaded (if all the conditions
are met of course). You can also start Vim in different location and load your
project using Proset function or command (which implies changing current
working directory to project root path).

To make life easier Proset offers function and command for creating project as
well. It means that you can very easily create dummy project, that you can
load. It will create Proset configuration file for specific Proset Settings
using some default values that can be configured as well (more on this later)
and (probably, because it depends) some source code and/or directories.

==============================================================================
SETTINGS                                                     *proset:settings*
==============================================================================

Proset Settings is something that stores all your project specific
configuration. It is implemented as a dictionary with specific interface (see
|Dictionary-function|, |numbered-function|). Object of such dictionary can be
registered in the plugin, either by plugin itself, or by you if your Settings
Dictionary is not supported by the plugin.

Settings Dictionary and Settings Object are basically what is in object
oriented languages known as class and instance of that class (object) and
therefore from now on I will refer rather to Settings Object than to Settings
Dictionary because object can be registered in the plugin and type can not.
Additionally, what is worth to notice is the fact that from one Settings
Dictionary (type) you can create multiple objects which can be registered as
long as they have different names.

Each Settings Object has to have a name (unique among other registered
Settings Objects) and it is not about object name in the code, but the string
coming from its function. This name is used to register Settings Object in
the plugin or when decision has to be made which Settings Object to choose
based on the string from configuration file.

Supported Settings Dictionaries can be found under plugin/settings/ directory.
Each Settings Dictionary definition (except Default) is placed there with
a meaningful name roughly speaking what is it for.

For example:
plugin/settings/cxx-cmake.vim

See also |proset:supported_settings_dictionaries|.

                                                     *proset:settings:default*

There is a special Settings Dictionary called Default (defined in
autoload/proset/settings/default.vim file) that has two reasons to exist:

    - default settings (no settings at all) - in case when plugin is enabled,
      but no configuration file is found, so probably most of the time you
      start Vim,
    - interface definition - all Settings Dictionaries have to have the same
      public interface as Default one has and they have to have public
      constructor even though Default does not have one since it is special
      case Settings Dictionary.

One more thing:

You will use Proset plugin by its public functions or commands, however some
of those functions does not have any logic, they use Settings Object (which
has the logic) to do the task and possibly return value. In object oriented
world this is known as composition. Settings Object that Proset plugin is
currently operating on is referred as current in the following documentation.

==============================================================================
PLUGIN VARIABLES                                            *proset:variables*
==============================================================================

                                                      *g:proset_settings_file*
This variable stores path to project settings file. It has to be a relative
subpath to current working directory. Error *proset-E1* may occur if value
results in:

    - empty value,
    - current directory ("."),
    - global path ("/tmp/settings", even if it leads you below your current
      working directory),
    - path above current working directory ("..").

Default value is ".vim-proset/settings.json".

To change default value, put this in your vimrc:

 let g:proset_settings_file = ".ide/cfg"

Variable can not be altered on the fly.

                                                       *g:proset_json_encoder*
This is dictionary that stores two keys:

    - g:proset_json_encoder.function - function name (string) of JSON encoder
      function (a function that creates JSON string from dictionary), by
      default set to "proset#lib#json_encode#encode",

    - g:proset_json_encoder.options - dictionary with options for above
      function, which is passed as second (after JSON model dictionary)
      function argument when call to function is made.

If plugin supported JSON encoder function and its options do not fit your
needs, you are able to provide your own function for that task.

Note:
Remember that if you want to throw an exception because you are not able to
convert dictionary to string, throw "proset:create:exception message" to make
Proset plugin work as expected.

==============================================================================
CONFIGURATION                                           *proset:configuration*
==============================================================================

The only one configuration file that is read and required by the plugin is
|g:proset_settings_file|. This is a JSON file. To get more familiar with the
format, please refer to RFC7159 document. Check out |json_decode()| to see how
Vim parses JSON string.

So, the simplest configuration file looks like this:

                                                   *proset:configuration:file*
{
    "proset_settings": "cxx-cmake"
}

This is the only one required configuration parameter. All other parameters
that are there are Settings Object specific, but the configuration file does
not have to have more parameters, you can read them on your own using your own
parser, you can even read them from multiple configuration files, etc, it is
up to you if you choose Vim JSON parser or not. However, all the examples are
presented for JSON configuration file and if you choose your own way then you
may encounter some problems that you need to solve on your own, especially for
creating project.

Comments and duplicate keys are not accepted by the parser.

                                                  *proset:configuration:get()*
Lets say config is a dictionary object created by |json_decode()|. To get
value from it, you can normally do it just like for any other dictionary,
meaning:

 let l:x_val = config["foo"]["boo"]

or even simpler

 let l:x_val = config.foo.boo

that is fine, you can do it, but if there is no such key in config dictionary,
you will get an error. So, you have to check if config |has_key()| returns
TRUE always before accesing it, or you may want to use a helper function that
returns default value when such key is not defined. This function is defined
in autoload/proset/lib/dict.vim and its signature looks like this:

 proset#lib#dict#get(dictionary, default_value, ...)

where:
    a:dictionary    - is a dictionary, here created by JSON parser,
    a:default_value - is a value which will be returned if dictionary does not
                      have key you specify in '...',
    ...             - variadic string arguments that is a "path" to the key.

So, to use get() function, you should do:

 let l:x_val = proset#lib#dict#get(config, 10, "foo", "boo")

and if key "foo.boo" was in the configuration file then l:x_val has its value,
otherwise it has value of 10, which is the default value passed as second
argument to get() function.

Use |ProsetGetConfiguration()| function to get configuration dictionary.

==============================================================================
EVENTS                                                         *proset:events*
==============================================================================

Proset plugin offers autocommand events to register Settings Objects and to
inform you that Settings Object was chosen.

                                                 *ProsetRegisterSettingsEvent*
ProsetRegisterSettingsEvent

If you want to register Settings Object, then you have to use this event, and
do this in an autocommand, like this:

 autocmd User ProsetRegisterSettingsEvent
         \ call ProsetRegisterSettings("cxx-cmake", "CXXCMakeCtor")

This event is fired before choosing Settings Object. Real example is presented
later in the documentation (|proset:settings_dictionary|) where you will find
requirements for constructor function.

                                         *ProsetRegisterInternalSettingsEvent*
ProsetRegisterInternalSettingsEvent

This event is used to register plugin supported Settings Objects. It is
exactly like |ProsetRegisterSettingsEvent|, except it is invoked before it.
This should not be used to register Settings Objects outside of the Proset
plugin.

                                                   *ProsetSettingsChosenEvent*
ProsetSettingsChosenEvent

Actions attached to this autocommand event are executed whenever Settings
Object is loaded, either automatically on Vim start, or manually using Proset
commands. In both cases current Settings Object is changed if possible. Before
VimEnter and ProsetSettingsChosenEvent, current Settings Object is initialized
to Default Settings Object. So, if you want to use public API before VimEnter
and you expect Proset to have actual Settings Object initialized, register
your action on this event, this way:

 function! Foo()
     let l:p = ProsetGetProperties()
 endfunction

 autocmd User ProsetSettingsChosenEvent call Foo()

For the manual loading case, current Settings Object is the one you loaded
before, or it can be Default Settings Object as well, if no Settings Object
was loaded.

==============================================================================
SETTINGS API                                             *proset:settings_api*
==============================================================================

Note:
When documentation says that something returns FALSE it means that it returns
0 and if something returns TRUE then it returns other |Number| than 0, most
likely 1.

To create new Settings Dictionary you need to follow interface that is defined
in |proset:settings:default| Settings Dictionary, and it is presented below.

Keep in mind that you will not use actual Settings Object directly. You will
use it via Proset public functions (|proset:api|).

                                            *proset:settings_api:is_project()*
s:settings.is_project()

Returns TRUE if it is a project and FALSE otherwise. Each Settings Object can
have different requirements, but lets say that if project directory (root
path) has "src" directory it is a project (TRUE) and if it does not have, it
is not a project (FALSE). Settings Object can return TRUE unconditionally as
well.

Important thing to know is that enable() and disable() are called only if
is_project() returns TRUE.

FALSE on Default Settings Object.

                                      *proset:settings_api:get_project_name()*
s:settings.get_project_name()

Returns project name as string. The value is probably taken from somewhere
else (after some parsing, that is my guess), rather than returned as string
literal from this function.

Empty string on Default Settings Object.

                                        *proset:settings_api:get_properties()*
s:settings.get_properties()

Returns properties of Settings Object as dictionary. Strongly depends on
actual Settings Object, so rather refer to it and do not depend on it. Can not
tell here what is inside. |ProsetGetProperties()| does deep copy of it.

Empty dictionary on Default Settings Object.

                                     *proset:settings_api:get_settings_name()*
s:settings.get_settings_name()

Returns settings name as string. This value (not the function!) is used to
register Settings Object in the plugin (find if such name already exists) and
to choose Settings Object to be loaded. This name has to be unique among other
Settings Objects. Additionaly it is helpful to find out which Settings Object
is currently loaded.

Empty string on Default Settings Object.

                                                *proset:settings_api:enable()*
s:settings.enable()

This function is where all settings are defined. In this function you do all
your mappings, settings, other plugins configuration, basically whatever you
want to do what is different from project to project (common settings probably
are placed in vimrc). You can even create some temporary directories, and
remove them later.

This function is called when Vim fires VimEnter event or user loads project
settings manually (|ProsetLoadSettings|) and when is_project() is TRUE.

This function does nothing on Default Settings Object.

                                               *proset:settings_api:disable()*
s:settings.disable()

This function is like a cleanup function. If you did something in enable(),
you should revert it to the original state. This is the right place to do it.

This function is called when Vim fires VimLeave event or user loads project
settings manually (|ProsetLoadSettings|) or user closes project settings
manually (|ProsetCloseSettings|) and when is_project() is TRUE.

This function does nothing on Default Settings Object.

                                                *proset:settings_api:create()*
s:settings.create(project_path, args)

This function is used to create your project. What does "project" mean is
basically up to you what you want. I suppose it is something like:

    - basic tree structure,
    - some template files like "main", license, documentation, etc,
    - build system file if Settings Object is for compiled language,
    - etc.

Above is specialized for concrete Settings Object, yet there are common things
that you have to follow to make it work as expected.

If for some reason you have to throw an exception because you can not proceed,
then throw "proset:create:exception message", it will be caught and error
message will be presented to the user. If you throw something else, then it
may not work properly.

Return value of this function is dictionary as follows:

{
    "dictionary":   {...},
    "project_name": "foo"
}

"dictionary" holds everything except "proset_settings" you want to convert
to JSON using plugin supported encoder or your own, provided by you via
|g:proset_json_encoder|. "proset_settings" is appended to "dictionary" level
up in the caller function.

"project_name" is name of you project of course. It has to be provided from
Settings Object to Proset because Proset knows only path where project has to
be created, it could use last part of the path but I believe it is not always
the case.

You do not create |g:proset_settings_file| on your own, this is Proset's job
to do that, you have to provide above information only.


a:project_path is of course path to your new project, provided by Proset
function. Directory will be created before this function is called.

a:args is a list (|a:000|) of additional arguments provided by ProsetCreate().
What is inside is specific for Settings Object, so Proset does not know that.
You may want to pass project name if you want (remember to return it).
Another example could be to pass information whether your project is an
application or library, etc.

                                             *proset:settings_api:construct()*
SDConstruct(config, options)

This is a public constructor of Settings Dictionary that is registered with
settings name in the plugin (|ProsetRegisterSettings()|). Name of it should
contain text that describes which Settings Dictionary we are operating on.
Please refer to |proset:settings_dictionary:constructor| to get a lot of
informations about constructor function.


Summary:
As you see, Default Settings Dictionary defines |numbered-function|s what is
in other languages known as methods or member functions.  For creating other
Settings Dictionaries you need to follow this scheme. To see how to register
Settings Object in the plugin, see |proset:settings_dictionary|.

                                              *proset:settings_api:exceptions*
Exceptions

Settings Object can throw an exception only from two functions (cases):

    - constructor function (|proset:settings_dictionary:constructor|),
    - |proset:settings_api:create()|,

and to make Proset plugin handle it, it has to be of known "type". Of course
it is not a type you may be familiar with from object oriented programming
languages, but it imitates it in some sense. So, you need to throw a string in
the form of:

1) for constructor

 "proset:construct-settings:x:y"

where:
    "proset:construct-settings"     - always the same string (lowercase),
    "x"                             - Settings Object name,
    "y"                             - reason (message) of exception.

 function! SDConstructor(config, options)
     throw "proset:construct-settings:sd-name:some error message"
 endfunction


2) for create()
 "proset:create:y"

where:
    "proset:create"                 - always the same string (lowercase),
    "y"                             - reason (message) of exception.


Note:
Technically exception can be thrown from any other place of Settings
Dictionary as well, however, it will work correctly only if exception is
thrown directly or indirectly from one of mentioned functions.

==============================================================================
API                                                               *proset:api*
==============================================================================

To interact with Proset plugin (besides plugin variables) you have to use
public API described below or commands defined later.

                                                    *ProsetRegisterSettings()*
ProsetRegisterSettings(settings_name, constructor_name)

This function is used to associate a:constructor_name with a:settings_name in
the internal storage. If a:settings_name key is already defined in internal
storage dictionary, then you will get *proset-E10* error and Proset plugin
will not work.  There is an assumption that registered Settings Objects names
are unique.

If user wants to register its own Settings Object then it should be called
from an autocommand, rather than just a function call from own plugin package.
Why? Own plugin package can be sourced before this plugin, so the function is
unknown there.  Using packadd to enable this plugin at the beginning of vimrc
is possible, but forcing user to do so is rather unacceptable.

Example:
 autocmd User ProsetRegisterSettingsEvent
         \ call ProsetRegisterSettings("cxx-cmake", "CXXCMakeConstruct")

Take a look at |proset:settings_dictionary| to see how to create Settings
Dictionary.

Note:
Important thing to know is the fact that Settings Object is created only when
needed. When Vim tries to load project settings and the conditions are met, it
takes proset_settings value from configuration file and checks if such name
was already registered. If so, it takes constructor function name that was
registered and use it to create Settings Object passing configuration
and options dictionaries as arguments.

                                                           *ProsetIsProject()*
ProsetIsProject()

This function is used to get information whether we are in the project. Each
Settings Object defines its own rules for that. Returns TRUE if it is a
project, FALSE otherwise.

                                                     *ProsetGetSettingsName()*
ProsetGetSettingsName()

This function is used to get current Settings Object name.

                                                      *ProsetGetProjectName()*
ProsetGetProjectName()

This function is used to get project name. Each Settings Object prepares
string with a name based on its own rules.

                                                       *ProsetGetProperties()*
ProsetGetProperties()

This function is used to get project properties in the form of a dictionary.
Each Settings Object prepares it in its own way. It creates deep copy of
returned value from Settings Object function.

                                                    *ProsetGetConfiguration()*
ProsetGetConfiguration()

This function is used to get configuration data (|proset:configuration:file|)
in the form of a dictionary - everything that was read from configuration
file. It creates deep copy of internal storage.

                                                        *ProsetLoadSettings()*
ProsetLoadSettings(path)

This function loads project settings from provided path. Even though loading
project settings function is called when Vim starts, it can also be called to
change projects settings (load different project, from different path).

First of all, checking if configuration file (|proset:configuration|) exists.
If missing, *proset-E20* is presented to you.

Then configuration file is parsed, if proset_settings parameter is empty or
missing you will get *proset-E21* error.

If syntax error (JSON format) occurs during parsing configuration file, then
*proset-E22* is what you get.

If configuration file has duplicate keys, then *proset-E23* occurs.

Configuration file can be correct, however if proset_settings holds value that
has not been registered (not supported Settings Object), then *proset-E30*
shows up.

There is also possibility that constructor of Settings Object throws an
exception due to some circumstances, then *proset-E40* is what you see.

If any error occurs during loading procedure, nothing happens with currently
loaded Settings Object.

If none of the above errors happen, then:
    - create chosen Settings Object using registered constructor function
      passing parsed configuration file as dictionary, options.mode set to
      "load" and treat it as current,
    - call disable() on previous Settings Object,
    - change current directory to a:path,
    - call enable() on current Settings Object,
    - execute actions registered on |ProsetSettingsChosenEvent| autocommand.

On success 0 is returned, on failure error code is returned.

Note:
You CAN NOT change current directory (|:cd|) and if you do so, then your
project settings will be closed using |ProsetCloseSettings()|. There are
reasons why, couple of them are:

    - beeing in a project means beeing in the root path of the project,
    - if enable() creates directory, the directory should be deleted in
      disable() - so if current directory changes between enable() and
      disable() what directory will be deleted?
    - it would be very inconvenient for Settings Objects commands like delete
      build files, create files, etc to be outside of the project root path.

                                                      *ProsetReloadSettings()*
ProsetReloadSettings()

This is the same as ProsetLoadSettings(".").

                                                       *ProsetCloseSettings()*
ProsetCloseSettings()

If you do not want your Vim to be in a project anymore, you can close Vim and
start over or you can use close functionality.

It will:

    - call disable() on current Settings Object,
    - set Default Settings Object as current one,
    - reset internal configuration dictionary causing
      |ProsetGetConfiguration()| to return an empty value.

This function does not return value.

                                                              *ProsetCreate()*
ProsetCreate(settings_name, path, ...)

This function creates project using a:settings_name, which defines which
Settings Object to choose to do that. Project will be created in a:path (trim
+ simplify()) directory, creating all the directory hierachy if needed.
Variadic parameters '...' are Settings Object specific input configuration, so
refer to actual one to find out if there are additional parameters and how
many.

What does "project" mean? It also depends on Settings Object, but it may be:

    - default values of settings/mappings that are written to
      |g:proset_settings_file| file,
    - project directory structure,
    - main file of your project,
    - etc.

This function uses specific Settings Object to do the main job, but it does
also things that are common for all. Here is what is done:

    - a:settings_name is checked if it was registered, if not you will see
      *proset-E50* error,
    - if a:path points to the existing directory then you will see
      *proset-E51* error,
    - create a:path directory with parents if needed,
    - choose Settings Object and call its contructor passing empty
      configuration dictionary and options.mode set to "create",
    - call |proset:settings_api:create()| to do the job of creating the
      project, which means, what is done depends strictly on Settings Object.
      Using its return value, content is written to |g:proset_settings_file|
      using |g:proset_json_encoder| function,
    - if |proset:settings_api:create()| throws an exception because creation
      is not possible then you will get *proset-E52* with information,
    - *proset-E53* will be shown if any other reason of error occurs during
      creation of a project.

In case of an error, directory that was created is removed.

==============================================================================
COMMANDS                                                     *proset:commands*
==============================================================================

Although you can use public API to do the same things, it is much more
convenient to use Vim commands for some of them.

*:ProsetLoadSettings* path                  - calls |ProsetLoadSettings()|,
*:ProsetReloadSettings*                     - calls |ProsetReloadSettings()|,
*:ProsetCloseSettings*                      - calls |ProsetCloseSettings()|.
*:ProsetCreate* settings_name path [args]   - calls |ProsetCreate()|.

==============================================================================
SETTINGS DICTIONARY                               *proset:settings_dictionary*
==============================================================================

Here, example (with explanation) of how to create Settings Dictionary is
provided.

Keep in mind that implementation you will see here is just an example. You can
store data in different form, as you like, as long as you implement the
interface.

There is no special difference between Settings Dictionary supported by the
plugin and the one written by you, except a place where it is stored and event
used to register it. Plugin supported Settings Dictionaries are placed under
plugin/settings directory and they use ProsetRegisterInternalSettingsEvent to
register itself. Yours rather should be stored in a separate plugin |package|
(vim-proset-ext, or the like) and have to use ProsetRegisterSettingsEvent.

                                      *proset:settings_dictionary:constructor*
Legacy Vim script (in which this plugin is written in) is not an object
oriented programming language, but it imitates it in some sense. Because of
that there is no constructor but we can use a function that creates an object
for us. Normally it would be called a factory function, but from now on when
you see a name constructor, I will refer to that function.

You can construct your Settings Object in several different ways I suppose,
however, a function that is called constructor has to take two parameters,
a:config and a:options which are configuration (|proset:configuration|) and
options dictionaries respectively.

Proset plugin is used for creating and loading projects, constructor then has
to have an option to distinguish between these two modes. So, a:options is a
dictionary (with only one key for now or forever) for this:

 { "mode": "load" } or { "mode": "create" }

When constructor is used for loading (|ProsetLoadSettings()|) a:options.mode
is set to "load" and a:config is a result of parsing |g:proset_settings_file|.
When constructor is used for creating (|ProsetCreate()|) a:option.mode is set
to "create" and a:config is an empty dictionary. Both parameters are provided
by Proset of course.

                                          *proset:settings_dictionary:package*
Create own plugin package

To create Vim package you have to create appropriate directory tree and then
create Vim script file there.

 $ mkdir -p ~/.vim/pack/vim-proset-ext/start/vim-proset-ext/plugin
 $ touch ~/.vim/pack/vim-proset-ext/start/vim-proset-ext/plugin/xd.vim

                                       *proset:settings_dictionary:definition*
Create Settings Dictionary definition

Note:
When you see "self.properties.some_key" then you should know that the key was
somehow initialized during construction of the Settings Object.

Put the following code in xd.vim file.


 if exists ("g:loaded_proset_settings_xd")
     finish
 endif
 let g:loaded_proset_settings_xd = 1

This is a common practice not to include Vim script file more than once.


 let s:obj = {"properties": {}}

This is the definition of the Settings Object that stores functions and data,
yet not initialized. It has "properties" key, but the name can be changed (if
so, you just need to update usages). Name s:obj can also be changed to the one
you like more, since it is script-local it does not really matter which one
you choose. The "properties" key contains all properties of the Settings
Object.


 function! s:obj.is_project()
     return self.properties.is_project
 endfunction

This function informs plugin whether we are in a project or not. Condition of
that is basically up to you. You need to remember that enable() and disable()
will be invoked only if return value from this function is TRUE.


 function! s:obj.get_project_name()
     return fnamemodify(getcwd(), ":t")
 endfunction

This function returns project name (string). How do you do it, it is up to
you. You can take value from configuration file, parse it from other file, you
can even return a string literal, but this should rather be avoided (since
project name would always be the same for all projects). Here, last part of
current working directory path is used.


 function! s:obj.get_properties()
     return self.properties
 endfunction

This function returns properties dictionary, all the properties you want, it
can be everything from configuration file, or more, or less, depends on you.


 function! s:obj.get_settings_name()
     return "xd"
 endfunction

This function returns Settings Object name (string), which can be helpful to
see what Settings Object is currently loaded. It has to be the same as value
used to register Settings Object.


 function! s:obj.enable()
     call mkdir(self.properties.tmpdir)
     nnoremap m0 :echo "Hello World"<CR>
 endfunction

Here you do everything you want, all your settings need to be here either
directly on indirectly using other functions.


 function! s:obj.disable()
     call delete(self.properties.tmpdir, "rf")
     nunmap m0
 endfunction

You can treat this function as a cleanup function.  It has to revert
everything that was done in enable(). Here temporary directory is deleted and
mapping is removed.


 function! s:obj.create(project_path, args)
     let l:tmpdir = "tmpdir"
     if len(a:args) == 1
         let l:tmpdir = a:args[0]
     endif
     return
     \ {
     \   "dictionary":
     \   {
     \       "is_project":   "1",
     \       "tmpdir":       l:tmpdir
     \   },
     \   "project_name":
     \   fnamemodify(a:project_path, ":t")
     \ }
 endfunction

This function is used to create project, just to be able to load it later.
Return value from this function is a dictionary with two keys:

    - "dictionary" stores JSON model as dictionary which is then encoded
      to string and written to a configuration file,
    - "project_name" stores project name of course - how it is calculated is
      basically up to you, but here I took last part of a:project_path.

a:project_path is a path (string) to the new project (directory to be created
along with missing parents). a:args is a list of additional parameters that
are specific for Settings Object and here for the example usage, there is
assumption that if a:args has one element then it is a name for temporary
directory that is created in enable() and removed in disable().
Both arguments are provided by |ProsetCreate()|.

                           *proset:settings_dictionary:constructor_one_object*
Before we start with the code, here is the sample |g:proset_settings_file|
file that is used as an example for both cases:

{
    "proset_settings":  "xd",
    "is_project":       "1",
    "tmpdir":           "tmpdir"
}

Settings Dictionary Constructor - one object only

 function! s:obj.construct(config)
     let l:ret = deepcopy(self)

     let l:ret.properties.is_project =
     \   proset#lib#dict#get(a:config, "0", "is_project")
     let l:ret.properties.tmpdir =
     \   proset#lib#dict#get(a:config, "tmpdir", "tmpdir")

     return l:ret
 endfunction

This is the internal implementation of Settings Dictionary constructor used
to create Settings Object. The object a:config is a configuration dictionary
that stores:

    - data coming from JSON configuration file when loading project,
    - nothing when creating project.

Helper function get() was used to handle case of missing entry in the file.


 function! XdConstruct(config, options)
     if a:options.mode == "load"
         " load
     elseif a:options.mode == "create"
         " create
     endif
     return s:obj.construct(a:config)
 endfunction

This is the public constructor that is used to create Settings Object by the
plugin when needed. It uses internal constructor implementation, but this is
not requirement, you can do as you like. This is just simple wrapper function
that is used to be registered. This function has to take exactly two
parameters which are configuration dictionary and options. If you want to
distinguish between load call and create call you can use a:options.mode.


 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd", "XdConstruct")

If you wonder why this is done in an autocommand, rather than just simple call
to ProsetRegisterSettings() the reason is that if you do this without an
autocommand and this code is sourced before Proset plugin then you get an
error that Proset* functions are not known (plugin has not been sourced yet).

So you need to inform Vim that you want to do this action but on user
autocommand that is invoked from the Proset plugin.

|ProsetRegisterSettings()| takes settings object name (string) and public
constructor function name (string) as arguments.

Having s:obj.get_settings_name() returning always the same value, we have only
one object of that Settings Dictionary that can be registered.  Remember that
value returned by this function HAS TO BE EXACTLY THE SAME as value passed as
first argument to ProsetRegisterSettings() function.

                     *proset:settings_dictionary:constructor_multiple_objects*
Settings Dictionary Constructor - multiple objects

 function! s:obj.get_settings_name()
     return self.properties.settings_name
 endfunction

This is different from previous implementation because it uses value that is
stored in a dictionary, which is initialized in the following constructor
implementation.


 function! s:obj.construct(config, settings_name)
     let l:ret = deepcopy(self)

     let l:ret.properties.is_project =
     \   proset#lib#dict#get(a:config, "0", "is_project")
     let l:ret.properties.tmpdir =
     \   proset#lib#dict#get(a:config, "tmpdir", "tmpdir")
     let l:ret.properties.settings_name = a:settings_name

     return l:ret
 endfunction

 function! Xd1Construct(config, options)
     return s:obj.construct(a:config, "xd1")
 endfunction

 function! Xd2Construct(config, options)
     return s:obj.construct(a:config, "xd2")
 endfunction

 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd1", "Xd1Construct")

 autocmd User ProsetRegisterSettingsEvent
      \ call ProsetRegisterSettings("xd2", "Xd2Construct")

So, this is one of the possible ways how you can create multiple Settings
Objects from one Settings Dictionary.


So, what does this "xd" Settings Object exactly do?

If configuration file has key "is_project" set to "1" then temporary directory
from "tmpdir" key (or default value if missing) will be created on enable()
along with mapping "m0" to print some text. On disable() temporary directory
will be deleted and "m0" will be unmapped.
If "is_project" is set to "0" or missing then enable() will not be called.
Nothing special, nothing more, just a simple example how to do it.

                                            *proset:settings_dictionary:usage*
The simplest way to use "xd" Settings Object is to start Vim and use command
for creating project this way:

 :ProsetCreate xd a/f1              " (1)
 :ProsetLoad a/f1                   " (2)
 :echo ProsetGetProjectName()       " prints "f1"
 :echo ProsetIsProject()            " prints 1
 :echo isdirectory("tmpdir")        " prints 1

(1) creates "f1" project (of "xd" Settings Object) in "a/f1" directory
creating "a" parent if needed.  You can see and update default project
settings in "a/f1/|g:proset_settings_file|".

(2) loads "f1" project which:

    - changes current working directory to "a/f1",
    - creates temporary directory "tmpdir".


The "xd" Settings Object gives you an option to pass additional (optional)
argument when creating project. This argument is a name for temporary
directory, so you are able to use different value than default "tmpdir" this
way:

 :ProsetCreate xd a/f2 temp
 :ProsetLoad a/f2
 :echo isdirectory("temp")          " prints 1

==============================================================================
SUPPORTED SETTINGS DICTIONARIES       *proset:supported_settings_dictionaries*
==============================================================================

List of supported Settings Dictionaries:

    - |cxx-cmake| - for C/C++ development using CMake as a build system,

==============================================================================
CONTRIBUTE                                                 *proset:contribute*
==============================================================================

If you see a bug, or something that can be improved, or have an idea of a new
Settings Dictionary or even better you have already written one and want it to
be supported by Proset plugin directly, just let me know via GitHub or email.

==============================================================================
 vim:tw=78:et:ft=help:norl:
